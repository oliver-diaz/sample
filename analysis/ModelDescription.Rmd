---
title: "Multiple Myeloma Treatment Sequencing Model"
subtitle: "Detailed Disease Progression and Economic Model Description"
author: "Oliver Diaz/ PHE"
#date: "2023-09-01"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
    bookdown::html_document2:
      toc: yes
      toc_depth: 2
      toc_float: true

     # bookdown::pdf_document2

bibliography: references.bib
biblio-style: apalike
csl: vancouver-author-date.csl
---

# Files and R Packages

## Model Storage and Installation

The model constructed from Janssen Pharmaceuticals is in the form of an RStudio project. The project is securely stored on Precision's GitHub repository. The model can be installed on a local computer by either creating a new project within RStudio and linking to the GitHub repository containing the model or downloading the project from GitHub as a zipped file and expanding it into a folder.

To run the model on a local machine, some addition configuration steps and utilities, which are beyond the scope of this document, may need to be installed on the local machine. For instance, an active GitHub account will be needed to download the GitHub repository, that account will need access to the online repository, and the local machine will need to account's token.

A RStudio project is a set of directories and files that contain data, code (`R`-Scripts), interactive analysis files (R-Markdown files), and outputs. Together, they are referred to as an `R` model.

This `R` model is organized into six directories:

1.  `R`: contains R scripts only. These scripts are the source code for the model. Unless noted, these scripts do not need to be run independently. They are called from within the analysis files.
    -   `initialize.R`: Installs missing R packages needed; create baseline input data that may be missing.
        -   After installing the project from GitHub with RStudio, this file should be run. This is also included within this file. This code checks to see if all needed packages used by the model are installed. If they are not, they will be downloaded from CRAN.org and installed.
        -   *NOTE: If errors are encountered when running this script, you may need to consult with you local IT resources.*
    -   The `R` input scripts: `surv_curves.R`, `medcost_data.R`, `tx_costs_data.R`, `utility_data.R` and `HR_data.R`. These analysis scripts generate baseline model inputs that are stored as `R data.frames`. Examples of these `data.frames` are: survival curves, HRs and uncertainty ranges, utilities, medical costs, and treatment costs.
    -   `eval_tx_costs.R`: creates a function that is used to evaluate discounted treatment costs for each line of treatment and sequence strategy.
    -   `TXcostsUpdate.R`: Updates annualized treatment costs based on WAC prices entered by user.
    -   `model_structure.R`: runs full model with baseline inputs.
    -   `aux_functions.R`: creates miscellaneous functions that do data or object manipulations.
2.  `data_raw`: contains Excel files where the different parameter inputs (survival curves, medical costs, drug costs and utilities) were analyzed and stored. This directly contains the source data used by several of the scripts (`surv_curves.R`, `medcost_data.R`, `tx_costs_data.R`, `utility_data.R` and `HR_data.R` ) in the `R` folder.
3.  `data`: contains the pre-analyzed `R data.frames` that are the input files for the model. These are the output files generated by processing the raw data input files through the `R` input scripts listed above. The model inputs are stored in the files
    -   `weilph.data.rda`: reference survival curves.
    -   `nonMM.data.rda`: non-MM survival curves estimated from US life-tables[@bureau_data_nodate]
    -   `medcost_data.rda`: list of medical costs.
    -   `base_wac.rda`: baseline WAC prices for treatment drugs.
    -   `baselineTX_data.rda`: Table with annualized costs and treatment schedule.
    -   `cost_tx_seq.rda`: list of treatment (or drug) costs and treatment schedule separated by sequence strategy.
    -   `utility_data.rda`: utility table.
    -   `HR.data.rda`: default baseline hazard ratio (HR) and uncertainty ranges.
4.  `analysis`: Markdown files, such as this one, that generate reports and documents in pdf format. We recommend using these markdowns as templates to run the model and for future customization of inputs and reports. Please review the section\@ref(using-an-r-markdown-file) for a brief description of how to use these files. The different markdown files are:
    -   `ModelDescription.Rmd`: *(This file)* generates a full description of the model and its implementation (components, inputs, output).
    -   `ModelDiseaseProg.Rmd`: runs disease progression model only.
    -   `Analysis.Rmd`: Runs full model (disease progression and economic analysis). It allows user to enter inputs for population, HRs, utilities, medical expenditures and WAC prices for treatment drugs. *NOTE: Due to the heterogeneity of in the dosing of drugs for the treatment of MM, a custom treatment cost function outside of the `Hesim` package* [@incerti2021hesim] *was developed. This can increase model run time considerably, and we recommend examining disease progression scenarios using the ModelDiseaseProg.Rmd file prior to conducting a full cost analysis using the Analysis.Rmd file.*
5.  `doc`: contains the diagram of the model schematics which is used by markdown files.
6.  `output`: Dedicated directory where output generated by the model is saved.

## Using an `R-markdown` file

A `R Markdown` file contains a combination of editable text and executable `R` code ([see: R Markdown Introduction](https://rmarkdown.rstudio.com/lesson-1.html)). There are two parts of the markdown files provided as part of this model. These are static text and code chunks. This `R Markdown` file is used to provide documentation of the model in the form of an interactive walk-through. The others are designed as reporting templates.

The `R Markdown` files are easily exported to a variety of formats including HTML and pdf files. This is done by 'knitting' the document. Knitting a document means the static text and executable code are combined into a final document contains the text, the executable code, and the output of that code including tables and graphs into a single document.

### Static Text

Static text is text contained in the markdown file that is not executable. Static text can be edited and customized using either the source code editor (source mode) or visual mode in RStudio. When editing static text in source mode, you will need to become familiar with the use of certain markdown characters such as \*\* for italics and #, ##, for headers.

Visual model ([see: Visual R Markdown](https://rstudio.github.io/visual-markdown-editing/)) provides a more traditional way to edit markdown files. Static text appears as it will in the final document, and there are drop-down menus and shortcuts for formatting, adding headers, and making citations.

You can toggle between source and visual model using the toggle buttons on the upper left.

### Code Chunks

Code chunks contain executable code. These appear as shaded sections within the document. An example appears at the top of this document. That code chunk (chunk) contains code that tells the RStudio how to format the output file once you knit it together. For instance, it specifies a title, a date, and how references are to be formatted.

Another example of a chunk is in the next section. Looking at the header of that chunk, `{r packgs, echo=TRUE, message=FALSE, warning=FALSE}`, it indicates the chunk contains `R` code and tells RStudio how output should be formatted when the document is knit together.

Chunks can also be executed interactively while the document is being edited. This is done by clicking on the green arrow at the top of each chunk. Within the `R Markdown` files provided, chunks are organized is order of how they need to be executed to first configure and then run the model. This is intended to consecutively to walk everyone through the files.

## Required `R` Packages

The model requires several `R` packages. `R` packages are publicly available programs that provide certain functionality. For example, this model depends upon the `hesim` package [@incerti2021hesim].

The `R` chunk below ' configures RStudio to run the rest of the model by loading all needed `R` packages as well as some supporting code created for this specific model. Specifically, this chunk:

1.  Loads all needed `R` packages: these appear as `library("package")` calls.
2.  Loads external functions: these appear as `source("../R/eval_tx_costs.R` and `source("aux_functions.R")` calls.

When the chunk is run, the associated output is added after the chunk.

```{r packgs, echo=TRUE, message=FALSE, warning=FALSE}
#  knitr::opts_chunk$set(echo = TRUE) make all chunks visible

# Load packages needed ----

library("hesim")
library("data.table")
library("survival")
library("flexsurv")
library("ggplot2")
library("dplyr")
library("kableExtra")
library("knitr")

source("../R/aux_functions.R") # miscellaneous functions
source('../R/eval_tx_cost.R') # function that  evaluates treatment costs
```

\newpage

# Model Structure

The model considers three strategies, each considers transitions across five lines of treatments. Within the model, these lines of therapy are represented as five, semi-Markov states. There are two additional states, relapsed from the fifth line of therapy into a palliative care state (R5: relapsed on 5L) and death.

## Model States {#states}

1.  $P1$: On 1L therapy.
2.  $R1\_P2$: relapsed on 1L; moved to 2L therapy.
3.  $R2\_P3$: relapsed on 2L; moved to 3L therapy.
4.  $R3\_P4$: relapsed on 3L; moved to 4L therapy.
5.  $R4\_P5$: relapsed on 4L; moved to 5L therapy.
6.  $R5$: relapsed on 5L therapy
7.  $\operatorname{Death}$.

## Treatment Sequences {#sequences}

The sequences examined in the model are:

1.  Sequence 1: (DVRd + ASCT + DR ) \> DKd \> EloPd \> Sd \> Cilta-cel.
2.  Sequence 2: (DVRd + ASCT + DR ) \> Cilta-cel \> TalDara \> Tec \> SKd.
3.  Sequence 3: (DVrd + DRd) \> Tec \> EloPd \> Tal \> Kd.

## Transitions {#transitions}

The model has eleven total transitions. There are two possible transitions from each line of therapy (states $P1$ through $R4\_P5$). The patient can relapse and proceed to the next line of therapy or they can die either from MM or another cause. There is a single transition to death from the palliative care state, $R5$ (relapsed on 5L therapy); $\operatorname{Death}$ is an absorbing state.

These transitions, noted as 1 through 11, are as follows:

1.  $P1 \rightarrow R1\_P2$
2.  $P1 \rightarrow Death$
3.  $R1\_P2 \rightarrow R2\_P3$
4.  $R1\_P2 \rightarrow Death$
5.  $R2\_P3 \rightarrow R3\_P4$
6.  $R2\_P3 \rightarrow Death$
7.  $R3\_P4 \rightarrow R4\_P5$
8.  $R3\_P4 \rightarrow Death$
9.  $R4\_P5 \rightarrow R5$
10. $R3\_P4 \rightarrow Death$
11. $R5 \rightarrow Death$

Figure \@ref(fig:fig1) illustrates the model structure.

```{r fig1, fig.cap= "\\label{fig:fig1}Model Structure",  echo=FALSE,  fig.show='hold',fig.align = "center",out.width="700px", fig.pos="H"}

knitr::include_graphics("../doc/model_structure.jpg")

```

The following R chunk defines the model structure for the `hesim` package. The square matrix, `tmat`, defines the model's states (see Section \@ref(states)) and the eleven transitions among those states \@ref(transitions). The `data.table`, strategies, specifies the model's three sequences that will be compared during analysis\@ref(sequences).

```{r mod_structure, echo=TRUE}
# States ----
tmat <- rbind( c(NA,1,NA,NA, NA, NA, 2),
               c(NA, NA, 3, NA, NA, NA , 4),
               c(NA, NA, NA, 5, NA, NA , 6),
               c(NA, NA, NA, NA, 7, NA , 8),
               c(NA, NA, NA, NA, NA, 9 , 10),
               c(NA, NA, NA, NA, NA, NA , 11),
               c(NA, NA, NA, NA, NA, NA , NA)
               )

colnames(tmat) <- rownames(tmat) <- c("P1", "R1_P2", "R2_P3", "R3_P4", "R4_P5","R5", "Death")
# print(tmat)

# Strategies ----
## Seq1: (DVRd + ASCT + DR )  > DKd         > EloPd   > Sd   > Cilta-cel ----
## Seq2: (DVRd + ASCT + DR )  > Cilta-cel  > TalDara > Tec  > SKd ----
## Seq3: (DVrd + DRd)         > Tec         > EloPd   > Tal  > Kd ----

strategies <- data.table(strategy_id = c(1, 2, 3),
                         strategy_name = c("Sequence 1", "Sequence 2", "Sequence 3"))

```

\newpage

# Simulation Runs: Population Size and Number of Model Parameter Input Samples

The model is an individual-level simulation model by which disease progression over time and expected outcomes for the population of interest are obtained by simulating repeatedly individual patients for a given set of model input parameter values. (The number of individuals simulated needs to be sufficiently large to miminize Monte Carlo error (or 1st order uncertainty) and obtain correct model output results for the set of input values). To propagate the uncertainty in model input parameters and reflect this in model output and cost-effectiveness results, the model runs repeatedly for different sets of randomly samples input parameter values.

You are able to set both the size of the simulated population for given model run (with a given set of model input values) as well as the number model runs. This is done through the two parameters defined in the chunk below. *NOTE: Increasing the population size will increase the time it takes to run each simulation (sample). This increased run time develops in a linear manner. Increasing the number of simulations have a larger impact on run time. For instance, increasing population size from 100 to 200 means each sample will have twice as many people to simulate; however, the sample number of simulation results will need to be configured, compiled and compared. In contrast, increasing samples from 100 to 200 given a population of 100 means results from an additional 100 simulations will need to be executed.*

-   For a quick run and demonstration of the model it is enough to set `n_patients <- 100` and `n_samples <- 100`.\
-   For robust results, a `n_patients>=1000` and `n_samples>=1000` is recommended.

```{r population, echo= TRUE}
# Population ----
n_patients <- 100 # population size
n_samples <- 100 # number of simulations (with different set of model input parameter values)
```

# Model Setup

Prior to performing analyses, several `data.frames` and `lists` that define the contours of the populations and potential pathways within the model need to be defined. These combine into a `hesim` object. This object will be used during analysis to define the population created for each simulation. No individual demographics such as age and gender are included in the model. This means that each simulated person has an equal risk of relapse and/or mortality given the current strategy and their current line of therapy within that strategy.

The following chunk creates the `hesim` object that defines the populations, strategies, and states in the model.

```{r popchar, echo =TRUE}
 ### No population covariates (age, gender, etc) are defined for this project
patients <- data.table(patient_id=1:n_patients)

no_death_states <- ncol(tmat)-1
states <- data.table(state_id = 1:no_death_states,
                     state_name = rownames(tmat)[1:no_death_states]) # Non-death health states
hesim_dat <- hesim_data( strategies = strategies,
                         patients = patients,
                         states = states)
```

The following chunk labels the model transitions in the order listed earlier.

```{r transitions, echo=TRUE}
# Transitions ----
### Labels for the plots and summary tables.

labs <- get_labels(hesim_dat)
labs$transition_id <- c("P1-> R1_P2" = 1, 
                        "P1 -> Death" = 2,
                        "R1_P2 -> R2_P3" = 3,
                        "R1_P2 -> Death" = 4,
                        "R2_P3 -> R3_P4" = 5,
                        "R2_P3 -> Death" = 6,
                        "R3_P4 -> R4_P5" = 7,
                        "R3_P4 -> Death" = 8,
                        "R4_P5 -> R5" = 9,
                        "R4_P5 -> Death" = 10,
                        "R5 -> Death" = 11)
```

\newpage

# Parameters

## Model Transitions

Each transition is quantified by a survival distribution and expressed in terms of years. For instance, the transition between the initial line of therapy to the second, $P1\rightarrow R1\_P2$, for the first strategy, $DVRd+ASCT+DR\rightarrow\ DKd$, is quantified by the progression-free-survival (PFS) distribution of $DVRd+ASCT+DR$. Each simulated person's individual time-to-progression (TTP) is determined by a random draw from the $DVRd+ASCT+DR$ PFS distribution. Similarly, the $h^{P_{i},D}(t)$ transitions of \@ref(fig:fig1)) are quantified by overall survival (OS) distributions.

For states where multiple transitions are possible (e.g. Transitions from the first line of therapy, $DVRd+ASCT+DR$, to either the second ,$DKd$, or $Death$ in the first sequence), the exact path an individual follows from the starting state, $DVRd+ASCT+DR$, is determined by comparing that individual's random draws from the two competing survival distributions: the distribution corresponding to $DVRd+ASCT+DR\rightarrow\ DKd$ and $DVRd+ASCT+DR\rightarrow\ Death$ transitions.

The random draw with the lowest value determines both how long the individual was in the starting state (time-in-state) and the state they transition to. For instance, if an individual's random draw from the $DVRd+ASCT+DR\rightarrow\ DKd$ survival distribution is 4.25 (4 and 1/4 years or 51 months) and that individual's random draw from the $DVRd+ASCT+DR\rightarrow\ Death$ survival distribution is 3.33 (3 and 1/3 years or 40 months), that individual would transition from the $P1: \text{On } 1L$ therapy state to $Death$, and their $P1: \text{On } 1L$ therapy time-in-state would be 40 months. In contrast, were their random draw from the $DVRd+ASCT+DR\rightarrow\ \operatorname{Death}$ distribution 5.5 they would transition to the second line of therapy state, which for strategy 1 is $DKd$. Time in state determines quality adjusted life years (QALYs) and treatment costs.

All of the survival distributions in the model follow a two-parameter, proportional hazards Weibull distribution. These distributions are specified in two steps. First, a reference sequence is specified. The survival distributions of that reference sequence are informed by landmark clinical trials listed in the next section. The model allows the user to modify this reference sequence by applying HRs. These HRs adjust the survival distributions to the specific treatments for each sequence. The following sections describe the references sequences, how they are loaded into the model, and how they are adjusted to better reflect the efficacy of the treatments within each sequence by line of therapy (LOT).

### Progression Free Survival Distributions {#pfs-distributions}

Hazard rates $h^{P_{i},R_j}(t)$ for disease progression -see Figure (\@ref(fig:fig1))- are estimated based upon a selected set of landmark studies, that will be referred to the reference sequence. For each line of therapy in that reference sequence, published PFS Kaplan-Meir from identified landmark studies were digitized and pseudo-individual patient data (IPD) derived using the Guyot algorithm.[@RN299] Using this pseudo-IPD data, two-parameter Weibull survival models were estimated.

The landmark studies informing the reference sequence are:

-   Line 1, GRIFFIN [@griffin],
-   Line 2, CANDOR [@candor],
-   Line 3, ELOQUENT-3 [@eloquent3],
-   Line 4, STORM [@storm],
-   Line 5, Majes TEC-1 [@majestec].

### Overall Survival Distributions {#os-distributions}

Hazard rates $h^{P_{i},D}(t)$ for transition to death pro-progression -see Figure (\@ref(fig:fig1))-- are quantified by OS distributions. There are two ways to specify these distributions. The first is to use OS curves from a real-world, claims-based study[@braunlin_21]. That study estimated OS among MM patients by LOT. The figure below is a reproduction of the OS curves estimated in the Braunlin study. These curves were digitized, pseudo-IPD data generated, and the parameters of a Weibull distributions estimated in the same way they were estimated for the PFS distributions.

```{r braunlin, fig.cap= "\\label{fig:braunlin}Estimated Overall Survival Curves from Braunlin",  echo=FALSE,  fig.show='hold',fig.align = "center",out.width="700px", fig.pos="H"}

knitr::include_graphics("../doc/Braunlin_OS.jpg")

```

The second way to specify overall survival distributions is to use overall survival curves derived from US life tables[@bureau_data_nodate] and SEER cancer statistics[@RN134].  <!-- perhaps bureau_data_nodate-->

<!--- The figure below plots these curves.   Missing figure with curves

```{r seer, fig.cap= "\\label{fig:seer}Overall Survival from US Mortality Tables",  echo=TRUE,  fig.show='hold',fig.align = "center",out.width="700px", fig.pos="H"}

knitr::include_graphics("../doc/Braunlin_OS.jpg")

```
-->

### Setting Model Transitions

The `R` script, `surv_curves.R` loads the pseudo-IPD data and estimates the survival curves in the model. These estimated survival curves in the form of `R data objects` are loaded into the model. The estimated parameters and covariance matrices of these distributions are used by the `hesim` package to specific transitions unique to each sample. This script saved the estimated survival curves in the form of two `R lists` saved in the projects data folder.

The following chunk loads these two lists.

```{r transition_input, echo=TRUE}
load("../data/weilph.data.rda")   #Load PFS reference sequence and Braunlin OS estimates
load("../data/nonMM.data.rda")    #Load OS estimates from US mortality tables
```

#### Selecting Overall Survival Distributions {#selectingOS}

As noted in Section \@ref(os-distributions), there are two options with regards to the $h^{P_{i},D}(t)$ transitions. The value of the model parameter `OS_Braunlin` determines if OS distributions from the Braunlin paper or those derived from the US death tables will be used.

The following chunk allows you to select which OS distributions are used. These, along with the estimated PFS curves of the reference sequence are then loaded into a list of estimated survival curves `mod.fit`.

```{r define_transitions}
#Select the OS curves for the death transitions
OS_Braunlin <- 0  # 0: Use Braunlin OS Curves
                  # Other: Using nonMM estimated from US death tables

### Set Model Transitions --------
mod.fit <- vector( mode = 'list',length = length(labs$transition_id))

mod.fit <- vector( mode = 'list',length = length(labs$transition_id))  #a list containing the final user-selected survival distributions
if (OS_Braunlin ==0) {  #populate with the user selected pre-fit distributions
  mod.fit <- weilph.fit
} else {
  #Replace all of the overall survival curves with non MM mortality curves from US LifeTables
  mod.fit[[1]] <- weilph.fit[[1]]
  mod.fit[[2]] <- nonMM.fit[[1]]
  mod.fit[[3]] <- weilph.fit[[3]]
  mod.fit[[4]] <- nonMM.fit[[2]]
  mod.fit[[5]] <- weilph.fit[[5]]
  mod.fit[[6]] <- nonMM.fit[[3]]
  mod.fit[[7]] <- weilph.fit[[7]]
  mod.fit[[8]] <- nonMM.fit[[4]]
  mod.fit[[9]] <- weilph.fit[[9]]
  mod.fit[[10]] <- nonMM.fit[[5]]
  mod.fit[[11]] <- weilph.fit[[11]]  #Transitions from the palliative state are not adjusted by user selected parameters
}
```

#### Accounting for Uncertainty in Survival Functions {#uncertaintyHR}

Uncertainty regarding the estimated survival functions is captured within the model through sampling of the joint empirical parameter distributions of each estimated function. This is done using the `eval_rng` function of the \`hesim' package. Specifically, the estimated log-scale ($\log(m_\tau$)) and shape ($a_\tau$) of each parameter of the estimated survival functions included in the `mod.fit` are jointly sampled using a multivariate normal distributions informed by their estimated covariance structure.

When two different sequences $i$ and $j$ have the same transition at some line of treatment, then HRs $h_{\tau,i}$ and $h_{\tau,j}$ are collapsed into a single one. For example, sequences 1 and 2 use the same treatment on line of treatment 1; hence, the HRs for transition $P1\rightarrow R1\_P2$ in sequence 1 and 2 get collapsed to form a single one: $h_{\tau,not3}$.

The following performs that sampling.

```{r survival_input, echo=TRUE}
library(magrittr)
set.seed(3455)
transmod_coef_def <- define_rng({
  for(i in 1:length(labs$transition_id)){
    assign(paste0("t",i),multi_normal_rng(mu = weilph.fit[[i]]$res.t[,1], 
                                          Sigma = vcov(weilph.fit[[i]]))) 
  }
  list(
    t1_shape = vec_to_dt(t1$shape),
    t1_scale = t1[, -1,] |> (\(x){colnames(x)=c("cons",  "notst3", "st3"); return(x)})() ,
    t2_shape = vec_to_dt(t2$shape),
    t2_scale = t2[, -1,] |> (\(x){colnames(x)=c("cons", "notst3", "st3"); return(x)})() , 
    t3_shape = vec_to_dt(t3$shape),
    t3_scale = t3[, -1,] |> (\(x){colnames(x)=c("cons", "st1", "st2", "st3"); return(x)})() ,
    t4_shape = vec_to_dt(t4$shape),
    t4_scale = t4[, -1,] |> (\(x){colnames(x)=c("cons", "st1", "st2", "st3"); return(x)})() ,
    t5_shape = vec_to_dt(t5$shape),
    t5_scale = t5[, -1,] |> (\(x){colnames(x)=c("cons", "notst2", "st2"); return(x)})() ,
    t6_shape = vec_to_dt(t6$shape),
    t6_scale = t6[, -1,] |> (\(x){colnames(x)=c("cons", "notst2", "st2"); return(x)})() ,
    t7_shape = vec_to_dt(t7$shape),
    t7_scale = t7[, -1,] |> (\(x){colnames(x)=c("cons", "st1", "st2", "st3"); return(x)})() ,
    t8_shape = vec_to_dt(t8$shape),
    t8_scale = t8[, -1,] |> (\(x){colnames(x)=c("cons", "st1", "st2", "st3"); return(x)})() ,
    t9_shape = vec_to_dt(t9$shape),
    t9_scale = t9[, -1,] |> (\(x){colnames(x)=c("cons", "st1", "st2", "st3"); return(x)})() ,
    t10_shape = vec_to_dt(t10$shape),
    t10_scale = t10[, -1,] |> (\(x){colnames(x)=c("cons", "st1", "st2", "st3"); return(x)})() ,
    t11_shape = vec_to_dt(t11$shape),
    t11_scale = t11[, -1,] |> (\(x){colnames(x)=c("cons"); return(x)})()
  )
}, n = n_samples)

transmod_coef <- eval_rng(transmod_coef_def)
```

### Refinement to Modeled Treatments

As noted in the introduction to this Section, the estimated survival functions can be further refined. This is done in a two-step process. First, reference sequence efficacy is adjusted to a specific LOT. Then, the that adjusted efficacy is adjusted to the specific treatment in the model.

#### Step 1: Reference Sequence Adjustment {#step1}

The landmark studies comprising the reference sequence in Section \@ref(pfs-distributions) frequently included subjects across multiple lines of therapy. This is particularly true of studies determining treatment efficacy for later lines of therapy. To adjust and have sharper initial estimates of treatment efficacy for a specific line of therapy (LOT), key opinion leaders (KOLs) from Janssen were asked to provide HRs reflecting how survival distributions reported by the trials would change were enrollment in that trial restricted to only persons receiving that specific LOT.

Formally, if a given reference trial, $r$ of $R$, where $R$ represents the five reference LOT's, has an estimated survival function of the form

$$\begin{align}
S_r(t)&=\exp\big(-m_r t^{a_r}\big), (\#eq:one)
\end{align}$$

then its adjusted survival curve, given the KOL HR adjustment,$h_{r}$, becomes:

$$\begin{align}
S_{r,h_{r}}(t)&=\exp\big(-m_r t^{a_r}h_{r}\big) 
(\#eq:oneb)
\end{align}$$

#### Step 2: Treatment Adjustment

HRs provided by Janssen are applied to each of the adjusted reference survival functions \@ref(eq:oneb). These HRs represent key opinion leader (KOL) thoughts on how the treatments would perform relative to the adjusted reference sequence (ARS). Thus, the model considers the efficacy of each therapy relative to that of the reference sequence whose published efficacy has been adjusted to how those same KOLs think its efficacy would be for that specific LOT.

Formally, if a given transition $\tau$ based upon the reference survival curve $S_{r,h_{r}}(t)$ has reference survival model of the form

$$\begin{align}
S_{\tau(t)}=\exp(-m_\tau t^{a_\tau}) (\#eq:twoa)
\end{align}$$

the adjusted survival model would take the form

$$\begin{align}
S_\tau(t; j)=\exp\left(-m_\tau\Big(\sum^3_{k=1}\boldsymbol{1}_{\{j\}}(k)h_{\tau,k}\Big)t^{a_\tau}\right) (\#eq:twob)
\end{align}$$

where $h_{\tau,j}$ is the HR adjustment pertaining to transition $\tau$ when sequence $j$ is used.

#### Application to Overall Survival {#apptoOS}

Adjustments to the $h^{P_{i},D}(t)$ transitions to better align with the modeled treatments are possible. Specifically, the KOL provided HRs used to modify the ARS to the specific treatments included in the model in Step 2 above can also be used to modify the risk of mortality (i.e. the $h^{P_{i},D}(t)$ transitions). However, the magnitude of this adjustment can be reduced to reflect the fact that not all mortality within the model is attributable to MM. This reduction in magnitude is determined by the estimated percentage of mortality attributed to MM up to either the median time of PFS or the median time of OS.

The following illustrates this calculation using median PFS for the first LOT. Here, the survival curves from both the Braunlin paper and that derived from the US death tables are inverted and represented cumulative mortality. The mortality curve derived from the Braulin paper includes death from any cause *among those with MM*. In contrast, the mortality curve derived from the US death tables pertains to the entire US population for which risk of death due to MM is minimal. Thus, the excess mortality observed among the MM group (Braunlin paper) can be interpreted as disease-specific mortality, and the area between the curves up the the point of PFS the percentage of overall mortality attributable to MM.

<!--- ![Estimated Mortality attributable to MM](images/Mortality_Adjustment.jpg) -->

```{r mortalityfig, fig.cap= "\\label{fig:mortalityfig}Mortality Adjustment Curves",  echo=FALSE,  fig.show='hold',fig.align = "center",out.width="700px", fig.pos="H"}

knitr::include_graphics("../doc/Mortality_Adjustment.jpg")

```

Similar calculations were conducted for all LOTS using both median PFS and median OS. These calculations are contained in the last section of the `surv_curve.R` script and imported into the model as the last to items in the `nonMM.data.rda` list.

The parameter `OS_HR` determines which adjustments are applied to the KOL HRs.

-   The default `OS_HR` equal to 0, uses median PFS, a value of 1 uses median OS, and any other value means no adjustment is applied.
-   If OS based upon US death tables is selected (see Section \@ref(selectingOS)) the mortality adjustment is turned off. This option essentially excludes MM-attributable mortality.

```{r OS_adjustments, echo=TRUE}
OS_HR <- 0


if (OS_HR==0){
  mort.adj <- nonMM.fit[[6]]  #based upon percent of mortality up to median PFS
} else if(OS_HR==1){
  mort.adj <- nonMM.fit[[7]]  #based upon percent of mortality up to median OS
} else {
  mort.adj <- c(1,1,1,1,1)    #No adjustment
}

if (!(OS_Braunlin ==0)) {  #populate with the user selected pre-fit distributions
  mort.adj <- c(1,1,1,1,1)    #Force to no adjustment because only background mortality is used
}

```

#### Incorporating Hazard Ratio Adjustments {#incorparatingHR}

As noted in Section \@ref(pfs-distributions), KOL provided HRs adjust the reference sequence to specific each treatments efficacy. Within the model, uncertainty regarding these inputs is incorporated by sampling from the upper and lower values of the uncertainty range of each HR provided by the KOLs. These HR ranges are contained within a `list` of `data.frames`. Each item in the list contains the treatment-specific adjustments for for each treatment by LOT. To align with how the survival functions were estimated if two different sequences $i$ and $j$ have the same transition for a given LOT, their HRs $h_{\tau,i}$ and $h_{\tau,j}$ are collapsed.

The chunk below contains the HRs by LOT. Alternative adjustments can be entered by changing the values in this table. The lower portion generates a summary table of the values where `Adj to Ref Seq` pertains to the adjustments in step 1 in Section \@ref(step1).

```{r HRratesJanssen, echo=TRUE}
# Tables with HR ranges for each LOT (t1.hr-t5.hr and death from palliative state, td.hr)
HR.data <- list(
  t1.hr = data.frame(low = c(s1=1, notst3 = .8, st3 = .9), 
                     up  = c(s1=1, notst3 = .91, st3 = 1)
                     ),
  t2.hr = data.frame(low = c(s1=.74, st1 =.9, st2= .60, st3= .97), 
                     up  = c(s1=1.1, st1=.96, st2=.65,  st3= 1)
                     ),
  t3.hr = data.frame(low = c(s1=.59, notst2 =.9, st2= .8), 
                     up  = c(s1=1.54,notst2=.96, st2=.9)
                     ),
  t4.hr = data.frame(low = c(s1=1,  st1 =.9,  st2=.85, st3= .97), 
                     up  = c(s1=1,  st1 =.96, st2=.9,  st3= 1)
                     ),
  t5.hr = data.frame(low = c(s1=.83,  st1=.75, st2=.88, st3= .88),
                     up  = c(s1=1.3, st1=.8,  st2=1,   st3= 1)
                     ),
  td.hr = data.frame(low = c(s1=3, st1 =1, st2=1, st3=1), 
                     up  = c(s1=3, st1 =1, st2=1, st3=1)
                     )
)

#LOW PORTION
#DO NOT EDIT BELOW THIS LINE
#create a summary table of the HR adjustments*/


hr_names <- list(t1 = c('stage1', 'notst3', 'st3'),
                 t2 = c('stage1', paste0('st',1:3)),
                 t3 = c('stage1', 'notst3', 'st3'),
                 t4 = c('stage1', paste0('st',1:3)),
                 t5 = c('stage1', paste0('st',1:3)),
                 td = c('stage1', paste0('st',1:3)))
#tran_names <- names(labs$transition_id)
tran_names <- rownames(tmat)



hr <- copy(HR.data)
hr <- lapply(1:length(hr), function(k){data.table(hr[[k]])[, strategy := hr_names[[k]]] })
hr <- lapply(1:length(hr), function(k){hr[[k]][,LOT:= tran_names[k]]})
hr <- do.call(rbind, hr)

temp <-data.table(strategy =c("stage1", "st1", "st2", "st3", "notst2", "notst3"),
                  Sequence = c("stage1", "1", "2", "3", "Not 2", "Not 3"))
hr <- left_join(hr, temp, by ="strategy")[, .(Sequence, LOT,  low, up)]
hr <- hr[, Treatment := c(rep(c(stage1="Adj to Ref Seq", notst3 = "DVRd + ASCT + DR",   st3 = "DVrd + DRd"), 1),  # Line 1
                          rep(c(stage1="Adj to Ref Seq", st1 = "DKd", st2 = "Cilta-cel", st3= "Tec"),1), # Line 2
                          rep(c(stage1="Adj to Ref Seq", notst2 = "EloPd", st2 ="TalDara"),1),  # Line 3
                          rep(c(stage1="Adj to Ref Seq", "Sd", "Tec", "Tal"), 1),   # Line 4
                          rep(c(stage1="Adj to Ref Seq", "Cilta-cel", "SKd", "Kd"),1),  # Line 5
                          rep("Paliative",4))] # Line 5+
knitr::kable(hr[, c(2,5,3,4)],
  caption = "Hazard ratio ranges for each treatment",
  digits = 2, 
  booktabs = TRUE, valign = "t"
) %>%
  kableExtra::kable_styling(bootstrap_options = "striped", latex_options = "hold_position" )

rm(temp, tran_names, hr, hr_names)
```

#### Accounting for Uncertainty in Hazard Ratio Adjustments

Uncertainty regarding the KOL provided HR adjustments to both the reference sequence and specific treatments for each strategy is captured by simultaneous, uniform sampling across the range of values provided. Because a proportional hazards specification of the Weibull distribution was used when estimating the survival distributions defining the model's transitions, these HR adjustments are additive on the log scale and applied to the scale of the distribution.

OS distributions are further adjusted according to the selected estimate of disease-specific mortality as discussed earlier (see Section \@ref(apptoOS)). The selected mortality adjustment is applied to the deviation from 1 to reduce the amount is either decreases (HR\<0) or increases (HR\>1) the hazards of the transitions distribution.

Formally, let $HR_{i,j}\in[KOL_{Low} ,KOL_{High}]$ represent the sampled $HR$ of the $i^{th}$ transition of the $j^{th}$ sample, and $MA_{i} \in[0,1]$ the mortality adjustment that will be applied to the sampled $HR$ of the $i^{th}$ transition. The adjustment is applied the following way: 

$$\begin{align}
HR_{i,j} &= HR_{i,j} + 1 -1 \\
         &= 1 + (HR_{i,j} - 1)
\end{align}$$
where the latter term denotes the HR's net effect when a mortality adjustment is applied. The the adjustment factor is given by:
$$\begin{align}
AdjHR_{i,j} &=1 + (HR_{i,j} - 1)*MA_{i}
\end{align}$$

In the following chunk, adjustments to the survival functions generated earlier are made (see Section \@ref(uncertaintyHR)), and a table summarizing the results of the sampling is created.

```{r hrAdjustment, echo=TRUE}
#Sample HRs from KOLs by LOT
## The sampling is per LOT to ensure both PFS and OS survival are adjusted by the sample sampled HR
HR.data.samp <- list(
  cbind(
        s1   = runif(n_samples, HR.data$t1.hr$low[1], HR.data$t1$up[1]),
        notst3 = runif(n_samples, HR.data$t1.hr$low[2], HR.data$t1$up[2]),
        st3    = runif(n_samples, HR.data$t1.hr$low[3], HR.data$t1$up[3])
  ),
  cbind(
        s1   = runif(n_samples, HR.data$t2.hr$low[1], HR.data$t2$up[1]),
        st1  = runif(n_samples, HR.data$t2.hr$low[2], HR.data$t2$up[2]),
        st2  = runif(n_samples, HR.data$t2.hr$low[3], HR.data$t2$up[3]),
        st3  = runif(n_samples, HR.data$t2.hr$low[4], HR.data$t2$up[4])
  ),  
  cbind(
        s1   = runif(n_samples, HR.data$t3.hr$low[1], HR.data$t3$up[1]),
        notst3 = runif(n_samples, HR.data$t3.hr$low[2], HR.data$t3$up[2]),
        st3    = runif(n_samples, HR.data$t3.hr$low[3], HR.data$t3$up[3])
  ),
  cbind(
        s1   = runif(n_samples, HR.data$t4.hr$low[1], HR.data$t4$up[1]),
        st1  = runif(n_samples, HR.data$t4.hr$low[2], HR.data$t4$up[2]),
        st2  = runif(n_samples, HR.data$t4.hr$low[3], HR.data$t4$up[3]),
        st3  = runif(n_samples, HR.data$t4.hr$low[4], HR.data$t4$up[4])
  ),
  cbind(
        s1   = runif(n_samples, HR.data$t5.hr$low[1], HR.data$t5$up[1]),
        st1  = runif(n_samples, HR.data$t5.hr$low[2], HR.data$t5$up[2]),
        st2  = runif(n_samples, HR.data$t5.hr$low[3], HR.data$t5$up[3]),
        st3  = runif(n_samples, HR.data$t5.hr$low[4], HR.data$t5$up[4])
  ),
  cbind(
        s1   = runif(n_samples, HR.data$td.hr$low[1], HR.data$td$up[1]),
        st1  = runif(n_samples, HR.data$td.hr$low[2], HR.data$td$up[2]),
        st2  = runif(n_samples, HR.data$td.hr$low[3], HR.data$td$up[3]),
        st3  = runif(n_samples, HR.data$td.hr$low[4], HR.data$td$up[4])
  )
)

# Adjust scale according to (sampled) hazard ratios in HR.data.samp
# Apply mortality adjustment to all death transitions
    ## P1-> R1_P2 ----
    transmod_coef$t1_scale[,`:=`(
      cons   = cons + log(HR.data.samp[[1]][,1]),
      notst3 =        log(HR.data.samp[[1]][,2]),
      st3    =        log(HR.data.samp[[1]][,3])
    )]
    ### P1-> Death   
         #The (1+(HR.data.samp[[1]][,1]-1)*mort.adj[1])) adjusts the deviation from 1 of the samples HR
    transmod_coef$t2_scale[,`:=`( 
      cons   = cons + log((1+(HR.data.samp[[1]][,1]-1)*mort.adj[1])),
      notst3 =        log((1+(HR.data.samp[[1]][,2]-1)*mort.adj[1])),
      st3    =        log((1+(HR.data.samp[[1]][,3]-1)*mort.adj[1]))
    )]

    ###  R1_P2 -> R2_P3
    transmod_coef$t3_scale[,`:=`( 
      cons   = cons + log(HR.data.samp[[2]][,1]),
      st1    =        log(HR.data.samp[[2]][,2]),
      st2    =        log(HR.data.samp[[2]][,3]),
      st3    =        log(HR.data.samp[[2]][,4])
    )]
    ###  R1_P2 -> Death
         #The (1+(mort.adj[2]-1)) value reflects the mortality adjustment
    transmod_coef$t4_scale[,`:=`( 
      cons   = cons + log((1+(HR.data.samp[[2]][,1]-1)*mort.adj[2])),
      st1    =        log((1+(HR.data.samp[[2]][,2]-1)*mort.adj[2])),
      st2    =        log((1+(HR.data.samp[[2]][,3]-1)*mort.adj[2])),
      st3    =        log((1+(HR.data.samp[[2]][,4]-1)*mort.adj[2]))
    )]
    
    ### R2_P3 -> R3_P4
    transmod_coef$t5_scale[,`:=`( 
      cons   = cons + log(HR.data.samp[[3]][,1]),
      notst3 =        log(HR.data.samp[[3]][,2]),
      st3    =        log(HR.data.samp[[3]][,3])
    )]
    ### R2_P3 -> Death
    transmod_coef$t6_scale[ , `:=`( 
      cons   = cons + log((1+(HR.data.samp[[3]][,1]-1)*mort.adj[3])),
      notst3 =        log((1+(HR.data.samp[[3]][,2]-1)*mort.adj[3])),
      st3    =        log((1+(HR.data.samp[[3]][,3]-1)*mort.adj[3]))
    )]
    
    ### R3_P4 -> R4_P5
    transmod_coef$t3_scale[,`:=`( 
      cons   = cons + log(HR.data.samp[[4]][,1]),
      st1    =        log(HR.data.samp[[4]][,2]),
      st2    =        log(HR.data.samp[[4]][,3]),
      st3    =        log(HR.data.samp[[4]][,4])
    )]
    ### R3_P4 -> Death
    transmod_coef$t8_scale[, `:=`( 
      cons   = cons + log((1+(HR.data.samp[[4]][,1]-1)*mort.adj[4])),
      st1    =        log((1+(HR.data.samp[[4]][,2]-1)*mort.adj[4])),
      st2    =        log((1+(HR.data.samp[[4]][,3]-1)*mort.adj[4])),
      st3    =        log((1+(HR.data.samp[[4]][,4]-1)*mort.adj[4]))
    )]
    
    ### R4_P5 -> R5
    transmod_coef$t3_scale[,`:=`( 
      cons   = cons + log(HR.data.samp[[5]][,1]),
      st1    =        log(HR.data.samp[[5]][,2]),
      st2    =        log(HR.data.samp[[5]][,3]),
      st3    =        log(HR.data.samp[[5]][,4])
    )]
    ### R4_P5 -> Death
    transmod_coef$t10_scale[, `:=`( 
      cons   = cons + log((1+(HR.data.samp[[5]][,1]-1)*mort.adj[5])),
      st1    =        log((1+(HR.data.samp[[5]][,2]-1)*mort.adj[5])),
      st2    =        log((1+(HR.data.samp[[5]][,3]-1)*mort.adj[5])),
      st3    =        log((1+(HR.data.samp[[5]][,4]-1)*mort.adj[5]))
    )]
    
    ### R5 -> Death
    transmod_coef$t11_scale[, `:=`( 
      cons   = cons + log(HR.data.samp[[6]][,1]),
      st1    =        log(HR.data.samp[[6]][,2]),
      st2    =        log(HR.data.samp[[6]][,3]),
      st3    =        log(HR.data.samp[[6]][,4])
    )]
    rm(weilph.fit, HR.data, HR.data.samp)

```

Table \@ref(tab:paramsnippet) displays a few sampled Weibull parameters:

```{r paramsnippet, echo= FALSE}
snippet <- head(summary(transmod_coef),10)
knitr::kable(snippet,
  longtable = T,
  booktabs = T, linesep = "",
  caption = "Snippet of sampled survival paramerers"
  )  %>%
  kableExtra::kable_styling("striped", latex_options = "hold_position")#   kableExtra::kable_styling("striped", full_width = F)
rm(snippet)
  
```

## Utility

Utilities per sequence (`strateg_id`) and state (`state_id`) are used by the model to estimate QALYs. For each simulation of the model, utility values are sample from a beta distribution with mean $m$ and standard error $\varepsilon$. Table \@ref(tab:UtilTable) displays the predetermined utility values used in the study. The chunk below indicates how the predetermined utility inputs are loaded into the model to create a object that the `hesim` package used to estimate population QALYs. Uncertainty surrounding utility values is incorporated by sampling with the specified distributions of the utility weights.

The following code first loads literature-based utility estimates. Then, it creates a 'state-value object' that both identified the source data and its distribution. This object defined the utility weights applied to each state within the model. The final step is to capture uncertainty surrounding these values by sampling from the state objects at the sample level. This sampling means utility weights will vary across samples, but the same weight will be applied to all simulated individuals within a sample.

```{r utility, echo=TRUE}

# Utility ----
load("../data/utility_data.rda") # predetermined utility inputs

#create state-value object
utility_tbl <- stateval_tbl(utility_data,
                            dist = "beta")

#Define the utility model
utilitymod <- create_StateVals(utility_tbl, n = n_samples, hesim_data = hesim_dat)

```

The following code summarizes the utility weights used within the model.

```{r UtilTable, echo=FALSE}
knitr::kable(utility_tbl,
             longtable = T,
             booktabs = T, linesep = "",
             caption = "Utility parameters",
             align = "lcrrr") %>%
  kableExtra::kable_styling("striped", 
                            full_width =F,
                            latex_options = "hold_position")
#             kable_styling("striped", full_width = F)
             

```

\newpage

## Treatment Costs

Within a given line of treatment, different combinations of drugs may be used with particular schedules.

```{r loadtxcosts,  echo=TRUE}
load("../data/cost_tx_seq.rda") # loads tables with treatments costs by state and strategy
```

Table \@ref(tab:wactxcosts) shows the wholesale acquisition cost (WAC) per mg and method of administration for each drug used in the strategy sequences considered in this study.

```{r wactxcosts,  echo=FALSE}
load('../data/base_wac.rda')
knitr::kable(base_wac,
             digits = c(0,0,2,0,0),
             longtable = T,
             booktabs = T, linesep = "",
             caption = "Baseline costs/mg of treatment drugs",
             align = "lllrr") %>%
  kableExtra::kable_styling('striped', latex_options = "hold_position")
#             kable_styling("striped", full_width = F)
```

\newpage

Table \@ref(tab:txCostAndSchedule) shows the annualized cost and schedule of each drug used for each line of treatment.

```{r txCostAndSchedule,  echo=FALSE}
load('../data/baselineTX_data.rda')
temp <- baselineTX_data[,.(LOT, Drug_Code, Drug_Cost_Code,Cost, t_init, t_stop)]
temp <- left_join(temp,base_wac, by =c("Drug_Code"="Abbr"))
knitr::kable(temp[,.(LOT, Rx, Drug_Cost_Code, Cost, t_init, t_stop)],
             digits = c(0,0,0,2,4,4),
             longtable = T,
             booktabs = T, linesep = "",
             caption = "Annualized cost and schedule for each line of treatment",
             align = "lllrrr") %>%
  kableExtra::kable_styling('striped', latex_options = "hold_position")
#             kable_styling("striped", full_width = F)

rm(base_wac, baselineTX_data, temp)

```

\newpage

## Medical Costs

Medical costs are split in inpatient costs, outpatient costs, outpatient drug costs (drugs which are not part of the treatment and are applied during outpatient visits) and hospice costs. Table \@ref(tab:medcostip) shows only the predetermined medical inpatient costs used in the study. As with utilities, each simulation of the model samples values from a gamma distribution with some mean $\mu$ and standard error $\sigma$. The chunk below shows how the predetermined medical costs inputs are loaded to generate an object which the `hesim` package uses to estimate population medical costs.

A different state value object is created for each category of interest. The model simulates potential values at the sample similar to how utility weights were samples.

```{r medcost, echo=TRUE}

# MedCosts tables ----
load("../data/medcost_data.rda")

## Inpatient costs ----
medcostip_tbl <- stateval_tbl(medcost_data$inpatient,
                            dist = "gamma")
## Outpatient costs ----
medcostop_tbl <- stateval_tbl(medcost_data$outpatient,
                              dist = "gamma")
## Other outpatient drug costs ----
medcostoth_tbl <- stateval_tbl(medcost_data$other_outpatient_drugs,
                              dist = "gamma")
## Hospice costs (after progression from line 5) ----
medcosthospice_tbl <- stateval_tbl(medcost_data$hospice,
                              dist = "gamma")

medcostipmod <- create_StateVals(medcostip_tbl, n = n_samples, hesim_data = hesim_dat)
medcostopmod <- create_StateVals(medcostop_tbl, n = n_samples, hesim_data = hesim_dat)
medcostothmod <- create_StateVals(medcostoth_tbl, n = n_samples, hesim_data = hesim_dat)
medcosthospicemod <- create_StateVals(medcosthospice_tbl, n = n_samples, hesim_data = hesim_dat)

```

The following table summarizes the sampled costs by category.

```{r medcostip, echo=FALSE}
knitr::kable(medcostip_tbl,
longtable = T,
  booktabs = T, linesep = "",
  caption = "Medical Costs: Inpatient",
  align = "lcrrr") %>%
  kableExtra::kable_styling("striped", latex_options = "hold_position") #  kable_styling("striped", full_width = F)

```

# Simulation

Once all data are loaded into the model parametric sampling conducted, and state value objects created for all outcomes of interest, individual micro simulations are conducted. This is done by first finalizing the sampled parameters of the survival distributions defining the eleven transitions throughout the model. These distributions are finalized by specifying the distribution of each transition and the values of its parameters.

## Disease Model

### Finalizing Model Transitions

`Hesim` does not directly use the estimated model function objects or any embedded `R` functions for those objects such as `summary()` or `predict`. Instead, it requires the parameters values from those objects. More specifically, it requires the samples parameter values developed in the \@ref(model-transitions) section.

The following chunk does two things. First, it defines the survival parameters and distributions that will be used by `hesim` package to determine transitions through the model. Second, it generates an individual-level `data.frame` that specify each simulated person in the model. Once these steps are complete, the individual simulations can be run.

```{r trans_params_coef, echo=TRUE}

#Specify Model Parameters
transmod_params <- params_surv_list(
  # 1. P1-> R1_P2
  params_surv(coefs = list(shape = transmod_coef$t1_shape,
                           scale = transmod_coef$t1_scale), 
              dist = "weibullPH"),
  # 2. P1 -> Death
  params_surv(coefs = list(shape = transmod_coef$t2_shape,
                           scale = transmod_coef$t2_scale), 
              dist = "weibullPH"),
  # 3. R1_P2 -> R2_P3
  params_surv(coefs = list(shape = transmod_coef$t3_shape,
                           scale = transmod_coef$t3_scale), 
              dist = "weibullPH"),
  # 4. R1_P2 -> Death
  params_surv(coefs = list(shape = transmod_coef$t4_shape,
                           scale = transmod_coef$t4_scale), 
              dist = "weibullPH"),
  # 5. R2_P3 -> R3_P4
  params_surv(coefs = list(shape = transmod_coef$t5_shape,
                           scale = transmod_coef$t5_scale), 
              dist = "weibullPH"),
  # 6. R2_P3 -> Death
  params_surv(coefs = list(shape = transmod_coef$t6_shape,
                           scale = transmod_coef$t6_scale), 
              dist = "weibullPH"),
  # 7. R3_P4 -> R4_P5
  params_surv(coefs = list(shape = transmod_coef$t7_shape,
                           scale = transmod_coef$t7_scale), 
              dist = "weibullPH"),
  # 8 R3_P4 -> Death
  params_surv(coefs = list(shape = transmod_coef$t8_shape,
                           scale = transmod_coef$t8_scale),
              dist = "weibullPH"),
  # 9. R4_P5 -> R5
  params_surv(coefs = list(shape = transmod_coef$t9_shape,
                           scale = transmod_coef$t9_scale),
              dist = "weibullPH"),
  # 10. R4_P5 -> Death
  params_surv(coefs = list(shape = transmod_coef$t10_shape,
                           scale = transmod_coef$t10_scale),
              dist = "weibullPH"),
  # 11. R5 -> Death
  params_surv(coefs = list(shape = transmod_coef$t11_shape,
                           scale = transmod_coef$t11_scale),
              dist = "weibullPH")
)


#Create individual data
transmod_data <- expand(hesim_dat, by = c("strategies", "patients"))
transmod_data[, cons := 1]  ## constant term created by transmod
transmod_data[, st1:= ifelse(strategy_name == "Sequence 1",1,0) ]
transmod_data[, st2:= ifelse(strategy_name == "Sequence 2",1,0) ]
transmod_data[, st3:= ifelse(strategy_name == "Sequence 3",1,0) ]
transmod_data[, notst3:= ifelse(strategy_name != "Sequence 3",1,0)]
transmod_data[, notst2:= ifelse(strategy_name != "Sequence 2",1,0)]


```

### Defining the Individual-level Continuous Time State Transition Model

The next lines of code create the individual-level continuous time state transition model. It uses the transition parameters (`transmod_paras`), the population data along with the strategies (`transmod_data`) and the matrix of valid transitions within the model (`tmat`). This code does not conduct the analysis. It defines the contours of the simulation. For instance, the function `create_IndivCtstmTrans()` indicates a continuous state-time transition model object will be creates. The first argument to this function, `transmod_params`, specifies which distributions, proportional hazards Wiebull, will define each transition. The second, `transmod_data` the values of the distribution's parameters for each simulated population. The final parameter, `clock`, indicates if the calculation of risks should restart for each simulated person upon entry into a new state.

```{r transition_model, echo=TRUE}
# Transition model ----
transmod <- create_IndivCtstmTrans(transmod_params, 
                                   input_data = transmod_data,
                                   trans_mat = tmat,
                                   clock = "reset")

```

\newpage

## Cost Model

Economic analysis is conducted after disease progression and health outcomes are determined. It uses the outcomes from those analyses such as time in each state to determine the values for its outcomes.

The chunk below creates the economic model.

```{r econmod, echo=TRUE}
costmods <- list(Inpatient  = medcostipmod,
                 Outpatient = medcostopmod,
                 OtherOutRx = medcostothmod,
                 HOSPICE    = medcosthospicemod)
```

## Combining the Disease, Utility, and Cost Models

Analysis is conducted in an incremental manner. First, an individual-level simulation object that identified the disease transmission model, the utility model, and all other economic/cost outcomes is defined. Once this simulation object is defined, `hesim` has several built-in functions that can be applied to that simulation object in a manner similar to other `R` output objects.

The following chunk first defines the simulation model. Then, is applies in internal `hesim` function, `sim_disease()`, to simulated disease progression in the for all simulated persons across all samples.

```{r simulation_model, echo=TRUE}

#Define simulation object
econmod <- IndivCtstm$new(trans_model = transmod,
                          utility_model = utilitymod,
                          cost_models = costmods
)

# Simulate individual disease progression ----
# ptm <- proc.time()
econmod$sim_disease()
# proc.time() - ptm
```

Table \@ref(tab:disprogsnippet) shows a snippet of the output of the disease progression model.

```{r disprogsnippet, echo=FALSE}
snippet <- head(econmod$disprog_,10)  ### results from simulation

knitr::kable(snippet,
             longtable = T,
  booktabs = T, linesep = "",
  caption = "Disease progression output")  %>%
  kableExtra::kable_styling( bootstrap_options = 'striped',
    latex_options = "hold_position")#  kable_styling("striped", full_width = F)
```

# Model Output

Individual-level simulated outputs are generated for disease transitions and model states defined in the previous section. These are discussed iteratively in the following sections.

## Disease Progression

The following chunks creates tables to summarized disease progression model simulation including time to progression, time to death pre-progression, progression free survival, and OS by line of treatment. Each is discussed in a separate section that also contains a chunk to generate tables and graphical summaries.

```{r time_spent, echo=TRUE}
econmod$disprog_[, `:=`(transition = paste0(from,'_',to), time_spent= time_stop - time_start), ]
# Some useful summary tables ----
disprog <- copy(econmod$disprog_)

disprog <- disprog[,.( progressed = .N,
  mean_time_spent = mean(time_spent), 
  median_time_spent = median(time_spent)
  ),
  by = .(sample, strategy_id, transition, from, to,final)]

##  Time to progression summary ----
summary_dis <- disprog[,.( mean_progressed = mean(progressed),
                           mean_time_spent = mean(mean_time_spent), 
                           med_time_spent = mean(median_time_spent),
                           time_spent05 = quantile(mean_time_spent,.05), 
                           time_spent95 = quantile(mean_time_spent,.95)), 
                       .(strategy_id, from, to, transition)
                       ][order(strategy_id, transition)]
per_line <- summary_dis[, .(mean_entry = sum(mean_progressed)), by = .(strategy_id,from)]

summary_dis <- left_join(summary_dis,per_line,by = c("strategy_id","from"))

summary_dis <- summary_dis[,.(strategy_id, from, mean_entry, to, mean_progressed,  
                              med_time_spent, mean_time_spent, time_spent05, time_spent95)]
summary_dis[, `:=`(proportion= ifelse(mean_entry==0,"-", round(mean_progressed/mean_entry,2)),
                   init_prop = round(mean_entry/n_patients,2))
            ]
names(summary_dis) <- c("Strategy", "from", "Entered",
                         "to", "Exited",  "Median", "Mean",
                         "Low 5%", "Top 5%", "Proportion", "% of initial pop")
summary_dis <- summary_dis[, `:=`(`From Line` = ifelse(from == 6, "5+", from),
                                  `To Line` = ifelse(to == 7, "D", ifelse(to == 6, "5+",to)),
                                  `Median Duration` = round(Median,2),
                                  `Mean Duration` = round(Mean,2),
                                  `95% - CI` = paste0("(",round(`Low 5%`,2)," ,",
                                  round(`Top 5%`,2), ")")
                                  )]
summary_dis[, Transition := paste(`From Line`,'to', `To Line`)]
summary_dis <- summary_dis[,.(Strategy, `From Line`, `To Line`,
                              Transition, Proportion, `% of initial pop`,
                              `Median Duration`, `Mean Duration`,
                              `95% - CI`)]

rm(disprog) # remove object not needed anymore
```

### Time to Progression (TTP)

The chunk below creates a table (see Table \@ref(tab:summaryProg)) of summary statistics for time to progression (TTP).

```{r summaryProg, echo=TRUE}
## Progression and survival per line of treatment summary ----
tbl_summaryP <- summary_dis[`To Line`!= "D", .(
  Strategy, `% of initial pop`,
  Transition, `Proportion`,
  `Median Duration`, `Mean Duration`, 
  `95% - CI`)]
names(tbl_summaryP)[c(4,5,6)] <- c("% who progressed", "Median TTP", "Mean TTP")
 
knitr::kable(tbl_summaryP,
  longtable = T,
  booktabs = T, 
  caption = "Time to progression (TTP) per line of treatment",
  align = "lcrrrr") %>%
  kableExtra::kable_styling('striped', latex_options = "hold_position")
```

### Time to Death Pre-Progression (TTDP)

The next chunk creates a table (see Table \@ref(tab:summaryDeath)) showing a summary statistics time to death pre-progression (TTDP).

```{r summaryDeath, echo=TRUE, message=FALSE}
# progression to death summary
tbl_summaryD <- summary_dis[`To Line`== "D", .(
  Strategy, `% of initial pop`,
  Transition, `Proportion`,
  `Median Duration`, `Mean Duration`, 
  `95% - CI`)]
names(tbl_summaryD)[c(4,5,6)] <- c("% who died", "Median TTDP", "Mean TTDP")

knitr::kable(tbl_summaryD,
  longtable = T,
  booktabs = T,
  linesep = linesep(c(6,6,6)),
  caption = "Time to death pre-pregression (TTDP) per line of treatment",
  align = "lcrrrr") %>%
  kableExtra::kable_styling('striped', latex_options = "hold_position")

rm(summary_dis) # remove objects that are no longer needed
```

### Progression Free Survival (PFS)

The next chunk creates a table (see Table \@ref(tab:summaryPFS)) showing a summary statistics on progression free survival (PFS), that is time to progression or death pre-progression.

```{r summaryPFS, echo=TRUE, message=FALSE}
summary_dis <- econmod$disprog_[,.( mean_time_spent = mean(time_spent), 
                                median_time_spent = median(time_spent)
                                ),
                            by = .(sample, strategy_id, from)]

##  Time to progression summary ----
summary_dis <- summary_dis[,.(med_time_spent = mean(median_time_spent),
                          mean_time_spent = mean(mean_time_spent), 
                          time_spent05 = quantile(mean_time_spent,.05), 
                          time_spent95 = quantile(mean_time_spent,.95)), 
                       .(strategy_id, from)
                       ][order(strategy_id)]
per_line[,prop_init := mean_entry/n_patients]
summary_dis <- left_join(summary_dis, per_line[,.(strategy_id, from, prop_init)],
                         by = c('strategy_id', 'from'))
names(summary_dis) <- c("Strategy", "LOT",
                          "Median", "Mean",
                         "Low 5%", "Top 5%", "% of initial pop")
summary_dis <- summary_dis[, `:=`(`LOT` = ifelse(LOT == 6, "5+", LOT),
                                  `Median PFS` = round(Median,2),
                                  `Mean PFS` = round(Mean,2),
                                  `95% - CI` = paste0("(",round(`Low 5%`,2),", ",
                                  round(`Top 5%`,2), ")")
                                  )]

# PFS tbl
tbl_summaryPFS <- summary_dis[, .(Strategy, `% of initial pop`, LOT,
            `Median PFS`, `Mean PFS`, 
            `95% - CI`)]
tbl_summaryPFS$`% of initial pop` <- round(tbl_summaryPFS$`% of initial pop`,2)

knitr::kable(tbl_summaryPFS,
  longtable = T,
  booktabs = T,
  linesep = linesep(c(6,6,6)),
  caption = "Progression free survival (PFS) per line of treatment",
  align = "rrrrr") %>%
  kableExtra::kable_styling('striped', latex_options = "hold_position")

 rm(summary_dis, tbl_summaryPFS)
```

### Overall Survival

The next chunk creates a table (see Table \@ref(tab:summaryOS)) showing a summary statistics on OS per line of treatment.

```{r summaryOS, echo=FALSE}
summary_dis <- lapply(1:6, function(k){econmod$disprog_[from >= k, .(TTD = sum(time_spent)),
                                               by = .(sample, strategy_id, patient_id)]})
summary_dis <- lapply(1:6, function(k){ summary_dis[[k]][, from := k]})
summary_dis <- do.call(rbind, summary_dis)

summary_dis <- summary_dis[, .(OSmean = mean(TTD), OSmedian = median(TTD) ),
         by = .(sample, strategy_id, from)]
summary_dis <- summary_dis[,.(medianOS = mean(OSmedian),
                              meanOS = mean(OSmean),
                              low = quantile(OSmean, .025),
                              up = quantile(OSmean, .975)),
                           by = .(strategy_id, from)]
summary_dis <- summary_dis[order(strategy_id, from)]
summary_dis <- left_join(summary_dis, per_line[,.(strategy_id, from, prop_init)],
                         by = c('strategy_id', 'from'))
names(summary_dis) <- c("Strategy", "LOT",
                          "Median", "Mean",
                         "Low 5%", "Top 5%", "% of initial pop")
summary_dis <- summary_dis[, `:=`(`LOT` = ifelse(LOT == 6, "5+", LOT),
                                  `Median OS` = round(Median,2),
                                  `Mean OS` = round(Mean,2),
                                  `95% - CI` = paste0("(",round(`Low 5%`,2),", ",
                                  round(`Top 5%`,2), ")")
                                  )]

# OS tbl
tbl_summaryOS <- summary_dis[, .(Strategy, `% of initial pop`, LOT,
            `Median OS`, `Mean OS`, 
            `95% - CI`)]
tbl_summaryOS$`% of initial pop` <- round(tbl_summaryOS$`% of initial pop`,2)

knitr::kable(tbl_summaryOS,
  longtable = T,
  booktabs = T,
  linesep = linesep(c(6,6,6)),
  caption = "Overall survival (OS) from line of treatment",
  align = "rrrrr") %>%
  kableExtra::kable_styling('striped', latex_options = "hold_position")

 rm(summary_dis, tbl_summaryOS, per_line)

```

\newpage

### Time to Progression (TTP) at Second Line

A comparison of time to progression (TTP) at second line of treatment is done to evaluate the performance of the different sequence strategies. The chunk bellow creates a graph (see Figure \@ref(fig:figTTP2l)) displaying TTP for individuals who progressed to second line.

```{r figTTP2l,  fig.align='center', fig.cap="\\label{fig:fig2}TTP at 2nd line", fig.pos='H', echo=TRUE, warning=FALSE}
### Time to progression at second line ----
pfsl2.data <- econmod$disprog_[from ==2,] 
pfs_data <- lapply(seq(0,30, by =.5), 
                    function(x){data.table(t=x,pfsl2.data[,.(prob = mean(time_spent>x)),
                                                          by =.(sample,strategy_id)])})
pfs_data <- do.call(rbind, pfs_data)
pfs_data <- pfs_data[, .(prob_mean = mean(prob),
                         ci_l = quantile(prob, .025),
                         ci_u = quantile(prob, .975)),
                     by = .(t,strategy_id)]
setorder(pfs_data, strategy_id, t)
set_labels(pfs_data, labels = labs, new_names = c("strategy_name"))
ggplot(pfs_data, aes(x = t, y = prob_mean, col = strategy_name)) +
  geom_line() +  ylim(0,1) +
  geom_ribbon(aes(ymin = ci_l, ymax = ci_u, fill = strategy_name), alpha = .2, linetype=0) +
  xlab("Years") + ylab("Probability") +
  ggtitle("Time to Progression at 2nd Line") +
  theme(legend.position = "bottom",
        legend.title = element_blank(),
        plot.title = element_text(hjust = 0.5))

```

\newpage

### Progression Free Survival (PFS) at Second Line

A comparison of progression free survival (PFS) at second line of treatment is done to evaluate the performance of the different sequence strategies. The chunk bellow creates a graph (see Figure \@ref(fig:figPFS2l)) displaying the PFS for individuals who progressed to second line.

```{r figPFS2l,  fig.align='center', fig.cap="\\label{fig:fig2}PFS at 2nd line", fig.pos='H', echo=TRUE, warning=FALSE}
### Time to progression at second line ----
pfsl2.data <- econmod$disprog_[from ==2,] 
pfs_data <- lapply(seq(0,30, by =.5), 
                    function(x){data.table(t=x,pfsl2.data[,.(prob = mean(time_spent>x)),
                                                          by =.(sample,strategy_id)])})
pfs_data <- do.call(rbind, pfs_data)
pfs_data <- pfs_data[, .(prob_mean = mean(prob),
                         ci_l = quantile(prob, .025),
                         ci_u = quantile(prob, .975)),
                     by = .(t,strategy_id)]
setorder(pfs_data, strategy_id, t)
set_labels(pfs_data, labels = labs, new_names = c("strategy_name"))
ggplot(pfs_data, aes(x = t, y = prob_mean, col = strategy_name)) +
  geom_line() +  ylim(0,1) +
  geom_ribbon(aes(ymin = ci_l, ymax = ci_u, fill = strategy_name), alpha = .2, linetype=0) +
  xlab("Years") + ylab("Probability") +
  ggtitle("Progression Free Survival at 2nd Line") +
  theme(legend.position = "bottom",
        legend.title = element_blank(),
        plot.title = element_text(hjust = 0.5))

```

\newpage

### Overall Survival from Second Line.

To further evaluate the performance of the second line treatments of each strategy sequence, a comparison of the OS starting from second line is useful. The chunk bellow creates a graph (see Figure \@ref(fig:fig2)) displaying the OS of individuals who progressed to second line for each sequence strategy in the model.

```{r fig2,  fig.align='center', fig.cap="\\label{fig:fig2}Overall survival from 2nd line", fig.pos='H', echo=TRUE, warning=FALSE}
rm(tbl_summaryD, tbl_summaryP) 

### Overall Survival for those who achieve second line ----

osl2.data <- econmod$disprog_[from!=1, .(OS = sum(time_spent)), 
                              by = .(sample, strategy_id, patient_id)]
prob_data <- lapply(seq(0,30, by =.5),
                    function(x){data.table(t=x,osl2.data[,.(prob = mean(OS>x)),
                                                         by =.(sample,strategy_id)])})
prob_data <- do.call(rbind, prob_data)
prob_data <- prob_data[, .(prob_mean = mean(prob),
                           ci_l = quantile(prob, .025),
                           ci_u = quantile(prob, .975)),
                       by = .(t,strategy_id)]
setorder(prob_data, strategy_id, t)
set_labels(prob_data, labels = labs, new_names = c("strategy_name"))
ggplot(prob_data, aes(x = t, y = prob_mean, col = strategy_name)) +
  geom_line() +  ylim(0,1) +
  geom_ribbon(aes(ymin = ci_l, ymax = ci_u, fill = strategy_name), alpha = .2, linetype=0) +
  xlab("Years") + ylab("Survival probability") +
  ggtitle("Overall Survival from 2nd Line") +
  theme(legend.position = "bottom",
        legend.title = element_blank(),
        plot.title = element_text(hjust = 0.5))
rm(osl2.data, prob_data, summary_dis) # remove objects that are no longer used
```

\newpage

### State Probabilities

The time evolution of state probabilities (probability that on individual is in any given state at any point in time) are also useful to evaluate the performance of the different sequence strategies. The chunk below creates a group of graphs showing the state probabilities (see Figure \@ref(fig:fig3)).

```{r fig3, fig.align='center', fig.cap="\\label{fig:fig3}State probabilities for each line of treatment per sequence", fig.pos='H', echo=TRUE, warning=FALSE,fig.dim = c(6, 8) }

 ## Plot of state probabilities ----
econmod$sim_stateprobs(t = seq(0, 30, .5)) 
summarize_stprobs <- function(stateprobs){
  x <- stateprobs[, .(prob_mean = mean(prob), 
                      low_prob_2.5 = quantile(prob, .025),
                      up_prob_2.5 = quantile(prob, .975)),
                  by = c("strategy_id", "state_id", "t")]
  set_labels(x, labels = labs, new_names = c("strategy_name", "state_name"))
}

stprobs <- summarize_stprobs(econmod$stateprobs_)
ggplot(stprobs, aes(x = t, y = prob_mean, col = strategy_name)) +
  geom_line() +  
  geom_ribbon(aes(ymin = low_prob_2.5, ymax = up_prob_2.5, fill = strategy_name), alpha = 0.2, linetype=0) +
  facet_wrap(~state_name,ncol = 2) + 
  xlab("Years") + ylab("Probability in health state") +
  # scale_color_discrete(name = "Strategy") +
  theme(legend.position = "bottom", 
        legend.title = element_blank())
```

\newpage

## Economic Outputs and Analysis

### QALYs and Medical Costs

A discount factor $v=(1+r)^{-1}$, $0\leq r<1$, is used in the model to estimate total discounted QALYs, medical and treatment costs. The following chunk defines the discount rate and factors.

```{r ecoanalysis, echo=TRUE}
disc <- 0.03 # Annual discount rate
v <- 1/(1+disc) # discount factor
```

The next chunk performs the estimation of total QALYs

```{r qalysim, echo=TRUE}
# QALYs model ----
econmod$sim_qalys(dr = disc)
```

A snippet of the output from the QALY model is in Table \@ref(tab:qalySimOut).

```{r qalySimOut, echo=FALSE}
snippet <- head(econmod$qalys_,10)
knitr::kable(snippet,
             digits = 2,
             longtable = T,
             booktabs = T, linesep = "",
             caption = "Snippet of QALY outcomes",
             align = "lcrrr") %>%
  kableExtra::kable_styling('striped', latex_options = "hold_position")
#             kable_styling("striped", full_width = F)
```

The next chunk performs the estimation of total medical costs.

```{r medcostsim, echo=TRUE}
# Medical Costs model ----
econmod$sim_costs(dr = disc)
```

A snippet of the output from the medical costs models is in Table \@ref(tab:medcostSimOut).

```{r medcostSimOut, echo=FALSE}
snippet <- head(econmod$costs_,10)
knitr::kable(snippet,
             digits = 2,
             longtable = T,
             booktabs = T, linesep = "",
             caption = "Snippet of medical cost outcomes",
             align = "lcrrr") %>%
kableExtra::kable_styling('striped', latex_options = "hold_position")
  #             kable_styling("striped", full_width = F)
             
```

\newpage

### Treatment Costs

Discounted treatment cost for any line of treatment are estimated based on the drug components and their schedules within each line of treatment. The cost of treatment is evaluated at the individual level and takes into account the individual sojourn times between transitions, and the scheduling for each drug used.

-   Suppose for example that an individual enters state $i$ at time $T_0$ and then transitions to state $j$ at time $T_1$.
-   Suppose that $N$ doses of drug `D` are schedule to start $t_0$ units of time after $T_0$, and applied at regular intervals of length $0<h\ll1$ units of time (in years). Let $t_1=t_0+Nh$.
    -   If $N>1$, and the annualized price per unit of drug `D` is $C_D$, then the cost accrued by this individual for drug `D` is 
    $$\begin{align}
         C_D\sum^{N-1}_{k=0}\mathbf{1}_{[T_0,T_1]}(t_0+kh)v^{T_0+t_0+kh}&=
        \frac{C_D}{h}\sum^{N-1}_{k=0}\mathbf{1}_{[T_0,T_1]}(t_0+kh)v^{T_0+t_0+kh} h\\
        &\approx
        \frac{C_D}{h}\int^{T_1}_{T_0}\mathbf{1}_{[t_0,t_1]}(t) v^t\, dt\\
        &=\frac{C_D}{h}\frac{ v^{\min(T_0+ t_0 ,T_1)} - v^{\min(T_0+ t_1 ,T_1)}}{-\log(v)}
        (\#eq:three)
    \end{align} $$
    -   If $N=1$, and the unit price of drug `D` is $C_D$, then \@ref(eq:three) reduces to 
    $$\begin{align}
         C_D v^{\min(T_0+t_0,T_1)}
          (\#eq:threep)
      \end{align}$$ 
      which is the same as $\lim_{h\rightarrow0}\frac{C_D}{h}\int^{T_1}_{T_0}\mathbf{1}_{[t_0,t_0+h]}(t)\,v^t\,dt$

Thus

-   When $N>1$ and $h\ll1$, the annualized cost in the treatment cost of `D` in the treatment cost input tables is $\frac{C_D}{h}$, `t_init=`$t_0=t_1=$`t_stop`.

-   When $N=1$, the annualized cost of drug `D` in the treatment cost input tables is $C_D$, and `t_init=t_stop=`=$t_0$.

The following chunk implements the computation described in \@ref(eq:three) for each drug used during the period of time between transitions.

```{r txcosts, echo=TRUE}
## Treatment cost estimation ----
disprog <- copy(econmod$disprog_)

# ptm <- proc.time()
disprog[,TX.cost:=cost_eval(strategy_id, from, time_start, time_stop, disc_fact = v)]
# proc.time() - ptm

txcosts <- disprog[,.(costs =mean(TX.cost)), 
                   by = .(sample,  grp_id, strategy_id, from)]
txcosts <- txcosts[, `:=`(category= "Drug", dr = disc)][, .(sample, strategy_id, 
                                                            grp_id, from, dr, 
                                                            category, costs),]
names(txcosts)[names(txcosts) == "from"] <- "state_id"
econmod$costs_ <- rbind(econmod$costs_, txcosts)
```

\newpage

## Economic Outputs

### QALYs

Chart \@ref(fig:fig4)) shows the average QALYs for each strategy sequence broken down by line of treatments.

```{r fig4, fig.align='center', fig.cap="\\label{fig:fig4}Expected QALYs per Treatment Sequence", fig.ps='H', echo=TRUE}
## Summary of average QALYs per line of treatment ----
qaly_chart <- chart.LOT(econmod$qalys_,'QALYs')
qaly_chart$plot + ggtitle("Mean QALYs") +
  theme(plot.title = element_text(hjust = 0.5) ) 
```

A similar chart (see Figure \@ref(fig:fig5) ) can be created for the average Life Years (LYs) per line of treatment.

```{r fig5, fig.align='center', fig.cap="\\label{fig:fig5}Expected LYs per Treatment Sequence", fig.ps='H', echo=TRUE}
qaly_chart <- chart.LOT(econmod$qalys_,'LYs')
qaly_chart$plot + ggtitle("Mean Life Years") +
  theme(plot.title = element_text(hjust = 0.5) )
```

\newpage

### Drug Costs

Chart \@ref(fig:TxCosts) shows the expected  costs of treatment (drugs)  for each strategy sequence broken down by line of treatment.

```{r TxCosts, fig.align='center', fig.cap="\\label{fig:TxCosts}Expected Drug Costs per Sequence Treatment", fig.ps='H', echo=TRUE}
tx_chart <- chart.LOT(df = econmod$costs_, categ = 'Drug')
tx_chart$plot + ggtitle("Mean Drug Costs") +
 theme(plot.title = element_text(hjust = 0.5) ) +
 scale_y_continuous(labels = scales::dollar_format(scale = 1e-6, suffix = "M"))
```

\newpage

### Other Medical Costs

Chart \@ref(fig:MedCosts) shows show the expected other medical costs for each strategy sequence broken down by line of treatment.

```{r MedCosts, fig.align='center', fig.cap="\\label{fig:TxCosts}Expected Other Medical Costs", fig.ps='H', echo=TRUE}
medcost_chart <- chart.LOT(econmod$costs_,'Other Medical Costs')
medcost_chart$plot  + ggtitle("Mean Other Medical Expenses") +
  theme(plot.title = element_text(hjust = 0.5) ) +
  scale_y_continuous(labels = scales::dollar_format(scale = 1e-3, suffix = "K"))
```

# Summary

Tables \@ref(tab:summaryqalys) and \@ref(tab:summarycosts) show summaries of the expected medical costs, drug costs and QALYs for each of the strategy sequences considered in this study.

```{r summaryqalys, echo=TRUE}
ce_sim <- econmod$summarize()
pp <- format(summary(ce_sim, labels = labs))
pp$Outcome <- c('QALYs', 'Inpatient',  'Outpatient',
                'OtherOutRx', 'HOSPICE',  'Drug', 'Total')
knitr::kable(pp[1,-1],
             longtable = T,
             booktabs = T, # linesep = linesep(c(1,6)),
             caption = "QALYs summary") %>%
  kableExtra::kable_styling('striped', latex_options = "hold_position")
```

```{r summarycosts, echo=TRUE}
knitr::kable(pp[-1,-1],
             longtable = T,
             booktabs = T, # linesep = linesep(c(1,6)),
             caption = "Economic output summary") %>%
  kableExtra::kable_styling('striped', latex_options = "hold_position")
```

------------------------------------------------------------------------

# References
