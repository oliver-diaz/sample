---
title: "Multiple Myeloma Treatment Sequencing Model"
subtitle: "Model Description: Disease Progression "
author: "Precision HEOR"
#date: "2023-09-01"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
    bookdown::html_document2:
      toc: yes
      toc_depth: 2
      toc_float: true

     # bookdown::pdf_document2

bibliography: references.bib
biblio-style: apalike
csl: vancouver-author-date.csl
---

# Files and R Packages

## Project Components

The `R` model implementation for this project is organized in six directories:

1.  `R`: contains R scripts only.
    -   `initialize.R`: Installs missing R packages needed; create baseline input data that may be missing. This should be the first script to be ran.
    -   The scripts `surv_curves.R`, `medcost_data.R`, `tx_costs_data.R`, `utility_data.R` and `HR_data.R` create baseline inputs for the model: survival curves, hazard ratios (HR), utilities, medical costs, and treatment costs.
    -   `eval_tx_costs.R`: creates a function that is used to evaluate discounted treatment costs for each line of treatment and sequence strategy.
    -   `TXcostsUpdate.R`: Updates annualized treatment costs based on WAC prices entered by user.
    -   `model_structure.R`: runs full model with baseline inputs.
    -   `aux_functions.R`: creates miscellaneous functions that do data or object manipulations.
2.  `data_raw`: contains Excel files where the different parameter inputs (survival curves, medical costs, drug costs and utilities) were analyzed and stored.
3.  `data`: contains the predetermined model input files. These files generated by processing the raw data input files through the R input scripts listed above. The model inputs are stored in the files
    -   `weilph.data.rda`: reference survival curves.
    -   `medcost_data.rda`: list of medical costs.
    -   `base_wac.rda`: baseline WAC prices for treatment drugs.
    -   `baselineTX_data.rda`: Table with annualized costs and treatment schedule.
    -   `cost_tx_seq.rda`: list of treatment (or drug) costs and treatment schedule separated by sequence strategy.
    -   `utility_data.rda`: utility table.
    -   `HR.data.rda`: default baseline HRs.
4.  `analysis`: Markdown files to generate automatic reports and documents. We recommend to use these markdowns as templates to run the model and for future customization of inputs.
    -   `ModelDescription.Rmd`: generates a full description of the model and its implementation (components, inputs, output).
    -   `ModelDiseaseProg.Rmd`: runs disease progression model only.
    -   `Analysis.Rmd`: Runs full model (disease progression and economic analysis). It allows user to enter inputs for population, HRs, utilities, medical expenditures and WAC prices for treatment drugs.
5.  `doc`: contains the diagram of the model schematics which is used by markdown files.
6.  `output`: Dedicated directory where output generated by the model is saved.

## `R` Packages

The `R` implementation of the model used in this project requires several packages to perform different functions. In particular, the analysis carried out for this project -disease progression, simulation, economic analysis,etc.- relies heavily on the `hesim` package [@incerti2021hesim].

The `R` chunk below

1.  Loads all needed `R` packages.
2.  Loads external functions (`eval_tx_costs.R`, `aux_functions.R`).

```{r packgs, message=FALSE}
#  knitr::opts_chunk$set(echo = TRUE) make all chunks visible

# Load packages needed ----

library("hesim")
library("data.table")
library("survival")
library("flexsurv")
library("ggplot2")
library("dplyr")
library("kableExtra")
library("knitr")

source("../R/aux_functions.R") # miscellaneous functions
source('../R/eval_tx_cost.R') # function that  evaluates treatment costs
```

\newpage

# Model Structure

In this analysis, we consider three different strategies, each one comprises transitions among five lines of treatments.

## Model States

1.  P1: On 1L therapy.
2.  R1_P2: relapsed on 1L; moved to 2L therapy.
3.  R2_P3: relapsed on 2L; moved to 3L therapy.
4.  R3_P4: relapsed on 3L; moved to 4L therapy.
5.  R4_P5: relapsed on 4L; moved to 5L therapy.
6.  R5: relapsed on 5L therapy.
7.  Death.

## Treatment Sequences

The sequences or strategies considered in this study are defined as follows:

1.  Sequence 1: (DVRd + ASCT + DR ) \> DKd \> EloPd \> Sd \> Cilta-cel.
2.  Sequence 2: (DVRd + ASCT + DR ) \> Cilta-cel \> TalDara \> Tec \> SKd.
3.  Sequence 3: (DVrd + DRd) \> Tec \> EloPd \> Tal \> Kd.

## Transitions

The transitions between lines of treatment depicted by the states defined above are given as follows:

1.  $P1 \rightarrow R1\_P2$
2.  $P1 \rightarrow Death$
3.  $R1\_P2 \rightarrow R2\_P3$
4.  $R1\_P2 \rightarrow Death$
5.  $R2\_P3 \rightarrow R3\_P4$
6.  $R2\_P3 \rightarrow Death$
7.  $R3\_P4 \rightarrow R4\_P5$
8.  $R3\_P4 \rightarrow Death$
9.  $R4\_P5 \rightarrow R5$
10. $R3\_P4 \rightarrow Death$
11. $R5 \rightarrow Death$

Figure \@ref(fig:fig1) illustrates the model structure. Observe that the "Death" state can be attained from any other state in the model.

```{r fig1, fig.cap= "\\label{fig:fig1}Model Structure",  echo=FALSE,  fig.show='hold',fig.align = "center",out.width="700px", fig.pos="H"}

knitr::include_graphics("../doc/model_structure.jpg")

```

The following R chunk defined the model structure for the `hesim` package.

```{r mod_structure, echo=TRUE}
# States ----
tmat <- rbind( c(NA,1,NA,NA, NA, NA, 2),
               c(NA, NA, 3, NA, NA, NA , 4),
               c(NA, NA, NA, 5, NA, NA , 6),
               c(NA, NA, NA, NA, 7, NA , 8),
               c(NA, NA, NA, NA, NA, 9 , 10),
               c(NA, NA, NA, NA, NA, NA , 11),
               c(NA, NA, NA, NA, NA, NA , NA)
               )

colnames(tmat) <- rownames(tmat) <- c("P1", "R1_P2", "R2_P3", "R3_P4", "R4_P5","R5", "Death")
# print(tmat)

# Strategies ----
## Seq1: (DVRd + ASCT + DR )  > DKd         > EloPd   > Sd   > Cilta-cel ----
## Seq2: (DVRd + ASCT + DR )  > Cilta-cel  > TalDara > Tec  > SKd ----
## Seq3: (DVrd + DRd)         > Tec         > EloPd   > Tal  > Kd ----

strategies <- data.table(strategy_id = c(1, 2, 3),
                         strategy_name = c("Sequence 1", "Sequence 2", "Sequence 3"))

```

\newpage

# Simulation Runs: Population Size and Number of Model Parameter Input Samples

The model is an individual-level simulation model by which disease progression over time and expected outcomes for the population of interest are obtained by simulating repeatedly individual patients for a given set of model input parameter values. (The number of individuals simulated needs to be sufficiently large to miminize Monte Carlo error (or 1st order uncertainty) and obtain correct model output results for the set of input values). To propagate the uncertainty in model input parameters and reflect this in model output and cost-effectiveness results, the model runs repeatedly for different sets of randomly samples input parameter values.

```{r population, echo= TRUE}
# Population ----
n_patients <- 2000 # user specified population size
n_samples <- 3000 #  user specified number of simulations (with different set of model input parameter values)
```

For this example, the population size and the number of samples are set to `r n_patients` and `r n_samples` respectively. The larger any of this values are, the longer it takes for the code to complete. 


# Model Setup

Prior to performing analyses, several `data.frames` and `lists` that define the contours of the populations and potential pathways within the model need to be defined. These combine into a `hesim` object. This object will be used during analysis to define the population created for each simulation. No individual demographics such as age and gender are included in the model. 

The following chunk creates the `hesim` object that defines the populations, strategies and states in the model.

```{r popchar, echo =TRUE}
 ### No population covariates (age, gender, etc) are defined for this project
patients <- data.table(patient_id=1:n_patients)

no_death_states <- ncol(tmat)-1
states <- data.table(state_id = 1:no_death_states,
                     state_name = rownames(tmat)[1:no_death_states]) # Non-death health states
hesim_dat <- hesim_data( strategies = strategies,
                         patients = patients,
                         states = states)
```

The following chunk assigned labels the transitions in the model in the order listed in the beginning of this report.

```{r transitions, echo=TRUE}
# Transitions ----
### Labels for the plots and summary tables.

labs <- get_labels(hesim_dat)
labs$transition_id <- c("P1-> R1_P2" = 1, 
                        "P1 -> Death" = 2,
                        "R1_P2 -> R2_P3" = 3,
                        "R1_P2 -> Death" = 4,
                        "R2_P3 -> R3_P4" = 5,
                        "R2_P3 -> Death" = 6,
                        "R3_P4 -> R4_P5" = 7,
                        "R3_P4 -> Death" = 8,
                        "R4_P5 -> R5" = 9,
                        "R4_P5 -> Death" = 10,
                        "R5 -> Death" = 11)
```

\newpage

# Model Input Parameters

## Survival

Weibull survival models are fitted using pseudo individual patient data (IPD) generated by digitizing PFS curves from the studies:

-   Line 1, GRIFFIN [@griffin],
-   Line 2, CANDOR [@candor],
-   Line 3, ELOQUENT-3 [@eloquent3],
-   Line 4, STORM [@storm],
-   Line 5, Majes TEC-1 [@majestec].

OS curves were derived from [@braunlin_21] for lines of treatment 1-5.

HRs provided by Janssen are applied to each of the fit models to assess the effect of each of the therapies considered in this study relative to the reference data. If a given transition $\tau$ has a reference survival model of the form \begin{align}
S_\tau(t)&=\exp\big(-m_\tau t^{a_\tau}\big),
(\#eq:one)
\end{align}

the adjusted survival model takes the form \begin{align}
S_\tau(t; j)=\exp\left(-m_\tau\Big(\sum^3_{k=1}\boldsymbol{1}_{\{j\}}(k)h_{\tau,k}\Big)t^{a_\tau}\right),
(\#eq:two)
\end{align}

where $h_{\tau,j}$ is the HR adjustment for transition $\tau$ when sequence $j$ is used.

To account for uncertainty:

-   Reference survival parameters log-scale ($\log(m_\tau$)) and shape ($a_\tau$) for each transition are sampled from multinormal distribution using the point estimates and covariance yielded by fitting Weibull models to the output generated by digitizing the reference curves.
-   HRs for each transition and sequence are sampled uniformly within uncertainty ranges provided by KOLs.
-   When two different sequences $i$ and $j$ have the same transition at some line of treatment, then HRs $h_{\tau,i}$ and $h_{\tau,j}$ are collapsed into a single one. For example, sequences 1 and 2 use the same treatment on line of treatment 1; hence, the HRs for transition $P1\rightarrow R1\_P2$ in sequence 1 and 2 get collapsed to form a single one: $h_{\tau,not3}$.

This chunk below HRs are defined for model purposes.

```{r HRratesJanssen, echo=TRUE}
# Tables with HRs and uncertainty ranges for each transition (t1,...,t11)
HR.data <- list(
  t1.hr = data.frame(low = c(notst3 = .45, st3 = 1), up= c(notst3 = .45, st3 = 1)),
  t2.hr = data.frame(low = c(notst3 = .45, st3 = 1), up= c(notst3 = .45, st3 = 1)),
  t3.hr = data.frame(low = c(st1 =1, st2= .83, st3= 1), up=c(st1=1, st2=.86, st3= 1)),
  t4.hr = data.frame(low =  c(st1 =1, st2= .83, st3= 1), up=c(st1=1, st2=.86, st3= 1)),
  t5.hr = data.frame(low = c(notst2 = 1, st2= .56), up=c(notst2= 1, st2=.56)),
  t6.hr = data.frame(low = c(notst2 = 1, st2= .56), up=c(notst2= 1, st2=.56)),
  t7.hr = data.frame(low = c(st1 = 1, st2= .08, st3= 1), up=c(st1=1, st2=.08, st3= 1)),
  t8.hr = data.frame(low = c(st1 = 1, st2= .08, st3= 1), up=c(st1=1, st2=.08, st3= 1)),
  t9.hr = data.frame(low = c(st1 =.43, st2= 1.9, st3= 1.2), up=c(st1=.43, st2=1.9, st3= 1.2)),
  t10.hr = data.frame(low = c(st1 = .43, st2 = 1.9, st3= 1.2), up=c(st1 = .43, st2 = 1.9, st3 = 1.2)),
  t11.hr = data.frame(low = c(st1 =2.8, st2 = 2.8, st3 = 2.8), up=c(st1=3.1, st2 = 3.1, st3= 3.1))
)
```

Table \@ref(tab:HRtbl) shows HRs and uncertainty ranges for each transition and sequence strategy.

```{r HRtbl, echo=FALSE}
hr_names <- list(t1 = c('notst3', 'st3'), t2 = c('notst3', 'st3'),
                 t3 = paste0('st',1:3), t4 = paste0('st',1:3),
                 t5 = c('notst2', 'st2'), t6 = c('notst2', 'st2'),
                 t7 = paste0('st',1:3), t8 = paste0('st',1:3),
                 t9 = paste0('st',1:3), t10 = paste0('st',1:3),
                 t11 = paste0('st',1:3))
tran_names <- names(labs$transition_id)
## Assign transition names to HR ranges
hr <- copy(HR.data)
hr <- lapply(1:11, function(k){data.table(hr[[k]])[, strategy := hr_names[[k]]] })
hr <- lapply(1:11, function(k){hr[[k]][,Transition:= tran_names[k]]})
hr <- do.call(rbind, hr)
temp <-data.table(strategy =c("st1", "st2", "st3", "notst2", "notst3"),
                  Sequence = c("1", "2", "3", "Not 2", "Not 3"))
hr <- left_join(hr, temp, by ="strategy")[, .(Sequence, Transition,  low, up)]
hr <- hr[, Treatment := c(rep(c(notst3 = "DVRd + ASCT + DR",   st3 = "DVrd + DRd"),2),  # Line 1
                          rep(c(st1 = "DKd", st2 = "Cilta-cel", st3= "Tec"),2), # Line 2
                          rep(c(notst2 = "EloPd", st2 ="TalDara"),2),  # Line 3
                          rep(c("Sd", "Tec", "Tal"), 2),   # Line 4
                          rep(c("Cilta-cel", "SKd", "Kd"),2),  # Line 5
                          rep("Paliative",3))] # Line 5+
knitr::kable(hr[, c(1,5,2, 3,4)],
  caption = "Hazard ratio for each treatment",
  digits = 2, 
  booktabs = TRUE, valign = "t"
) %>%
  kableExtra::kable_styling(bootstrap_options = "striped", latex_options = "hold_position" )

rm(temp, tran_names, hr, hr_names)
```

The survival model inputs (shape and scale parameters from Weibull fits) are fed into the `hesim` package. The covariance matrix estimated in the Weibull regression is used for parameter sampling (multinormal distribution) of scale and shape parameters. The next chunk indicates how this is done.

```{r survival_input, echo=TRUE}
load("../data/weilph.data.rda")

library(magrittr)
set.seed(3455)
transmod_coef_def <- define_rng({
  for(i in 1:length(labs$transition_id)){
    assign(paste0("t",i),multi_normal_rng(mu = weilph.fit[[i]]$res.t[,1], 
                                          Sigma = vcov(weilph.fit[[i]]))) 
  }
  list(
    t1_shape = vec_to_dt(t1$shape),
    t1_scale = t1[, -1,] |> (\(x){colnames(x)=c("cons",  "notst3", "st3"); return(x)})() ,
    t2_shape = vec_to_dt(t2$shape),
    t2_scale = t2[, -1,] |> (\(x){colnames(x)=c("cons", "notst3", "st3"); return(x)})() , 
    t3_shape = vec_to_dt(t3$shape),
    t3_scale = t3[, -1,] |> (\(x){colnames(x)=c("cons", "st1", "st2", "st3"); return(x)})() ,
    t4_shape = vec_to_dt(t4$shape),
    t4_scale = t4[, -1,] |> (\(x){colnames(x)=c("cons", "st1", "st2", "st3"); return(x)})() ,
    t5_shape = vec_to_dt(t5$shape),
    t5_scale = t5[, -1,] |> (\(x){colnames(x)=c("cons", "notst2", "st2"); return(x)})() ,
    t6_shape = vec_to_dt(t6$shape),
    t6_scale = t6[, -1,] |> (\(x){colnames(x)=c("cons", "notst2", "st2"); return(x)})() ,
    t7_shape = vec_to_dt(t7$shape),
    t7_scale = t7[, -1,] |> (\(x){colnames(x)=c("cons", "st1", "st2", "st3"); return(x)})() ,
    t8_shape = vec_to_dt(t8$shape),
    t8_scale = t8[, -1,] |> (\(x){colnames(x)=c("cons", "st1", "st2", "st3"); return(x)})() ,
    t9_shape = vec_to_dt(t9$shape),
    t9_scale = t9[, -1,] |> (\(x){colnames(x)=c("cons", "st1", "st2", "st3"); return(x)})() ,
    t10_shape = vec_to_dt(t10$shape),
    t10_scale = t10[, -1,] |> (\(x){colnames(x)=c("cons", "st1", "st2", "st3"); return(x)})() ,
    t11_shape = vec_to_dt(t11$shape),
    t11_scale = t11[, -1,] |> (\(x){colnames(x)=c("cons"); return(x)})()
  )
}, n = n_samples)

transmod_coef <- eval_rng(transmod_coef_def)
```

Once the sampling of survival parameters is established, HRs are applied to make adjustments. The following chink indicate how this is done

```{r hrAdjustment, echo=TRUE}
# Adjust scale according to (sampled) hazard ratios from KOLs
## P1-> R1_P2 ----
transmod_coef$t1_scale[,`:=`(
             notst3 = log(runif(n_samples,HR.data$t1.hr$low[1], HR.data$t1.hr$up[1])),
             st3 =  log(runif(n_samples,HR.data$t1.hr$low[2], HR.data$t1.hr$up[2]))
  )]

## P1-> Death----
transmod_coef$t2_scale[,`:=`( 
             notst3 = log(runif(n_samples,HR.data$t2.hr$low[1], HR.data$t2.hr$up[1])),
             st3 =  log(runif(n_samples,HR.data$t2.hr$low[2], HR.data$t2.hr$up[2]))
  )]

##  R1_P2 -> R2_P3 ----
transmod_coef$t3_scale[,`:=`( 
             st1 = log(runif(n_samples,HR.data$t3.hr$low[1], HR.data$t3.hr$up[1])),
             st2 =  log(runif(n_samples,HR.data$t3.hr$low[2], HR.data$t3.hr$up[2])),
             st3 =  log(runif(n_samples,HR.data$t3.hr$low[3], HR.data$t3.hr$up[3]))
  )]
##  R1_P2 -> Death ----
transmod_coef$t4_scale[,`:=`( 
             st1 = log(runif(n_samples,HR.data$t4.hr$low[1], HR.data$t4.hr$up[1])),
             st2 =  log(runif(n_samples,HR.data$t4.hr$low[2], HR.data$t4.hr$up[2])),
             st3 =  log(runif(n_samples,HR.data$t4.hr$low[3], HR.data$t4.hr$up[3]))
  )]

## R2_P3 -> R3_P4 ----
transmod_coef$t5_scale[,`:=`(
             notst2 = log(runif(n_samples,HR.data$t5.hr$low[1], HR.data$t5.hr$up[1])),
             st2 =  log(runif(n_samples,HR.data$t5.hr$low[2], HR.data$t5.hr$up[2]))
  )]
## R2_P3 -> Death ----
transmod_coef$t6_scale[ , `:=`(
             notst2 = log(runif(n_samples,HR.data$t6.hr$low[1], HR.data$t6.hr$up[1])),
             st2 =  log(runif(n_samples,HR.data$t6.hr$low[2], HR.data$t6.hr$up[2]))
  )]

## R3_P4 -> R4_P5 ----
transmod_coef$t7_scale[, `:=`( 
             st1 = log(runif(n_samples,HR.data$t7.hr$low[1], HR.data$t7.hr$up[1])),
             st2 =  log(runif(n_samples,HR.data$t7.hr$low[2], HR.data$t7.hr$up[2])),
             st3 =  log(runif(n_samples,HR.data$t7.hr$low[3], HR.data$t7.hr$up[3]))
  )]
## R3_P4 -> Death ----
transmod_coef$t8_scale[, `:=`( 
             st1 = log(runif(n_samples,HR.data$t8.hr$low[1], HR.data$t8.hr$up[1])),
             st2 =  log(runif(n_samples,HR.data$t8.hr$low[2], HR.data$t8.hr$up[2])),
             st3 =  log(runif(n_samples,HR.data$t8.hr$low[3], HR.data$t8.hr$up[3]))
  )]

## R4_P5 -> R5 ----
transmod_coef$t9_scale[, `:=`(  
             st1 = log(runif(n_samples,HR.data$t9.hr$low[1], HR.data$t9.hr$up[1])),
             st2 =  log(runif(n_samples,HR.data$t9.hr$low[2], HR.data$t9.hr$up[2])),
             st3 =  log(runif(n_samples,HR.data$t9.hr$low[3], HR.data$t9.hr$up[3]))
  )]
## R4_P5 -> Death ----
transmod_coef$t10_scale[, `:=`(  
             st1 = log(runif(n_samples,HR.data$t10.hr$low[1], HR.data$t10.hr$up[1])),
             st2 =  log(runif(n_samples,HR.data$t10.hr$low[2], HR.data$t10.hr$up[2])),
             st3 =  log(runif(n_samples,HR.data$t10.hr$low[3], HR.data$t10.hr$up[3]))
  )]
### R5 -> Death
transmod_coef$t11_scale[, `:=`(  
  st1 = log(runif(n_samples,HR.data$t11.hr$low[1], HR.data$t11.hr$up[1])),
  st2 =  log(runif(n_samples,HR.data$t11.hr$low[2], HR.data$t11.hr$up[2])),
  st3 =  log(runif(n_samples,HR.data$t11.hr$low[3], HR.data$t11.hr$up[3]))
)]

rm(weilph.fit, HR.data)

```

Table \@ref(tab:paramsnippet) displays a few sampled Weibull parameters:

```{r paramsnippet, echo= FALSE}
snippet <- head(summary(transmod_coef),10)
knitr::kable(snippet,
  longtable = T,
  booktabs = T, linesep = "",
  caption = "Snippet of sampled survival paramerers"
  )  %>%
  kableExtra::kable_styling("striped", latex_options = "hold_position")#   kableExtra::kable_styling("striped", full_width = F)
rm(snippet)
  
```

The following chunk defines the (sampled) survival parameters for each transition in the model used by the `hesim` package.

```{r trans_params_coef, echo=TRUE}
transmod_params <- params_surv_list(
  # 1. P1-> R1_P2
  params_surv(coefs = list(shape = transmod_coef$t1_shape,
                           scale = transmod_coef$t1_scale), 
              dist = "weibullPH"),
  # 2. P1 -> Death
  params_surv(coefs = list(shape = transmod_coef$t2_shape,
                           scale = transmod_coef$t2_scale), 
              dist = "weibullPH"),
  # 3. R1_P2 -> R2_P3
  params_surv(coefs = list(shape = transmod_coef$t3_shape,
                           scale = transmod_coef$t3_scale), 
              dist = "weibullPH"),
  # 4. R1_P2 -> Death
  params_surv(coefs = list(shape = transmod_coef$t4_shape,
                           scale = transmod_coef$t4_scale), 
              dist = "weibullPH"),
  # 5. R2_P3 -> R3_P4
  params_surv(coefs = list(shape = transmod_coef$t5_shape,
                           scale = transmod_coef$t5_scale), 
              dist = "weibullPH"),
  # 6. R2_P3 -> Death
  params_surv(coefs = list(shape = transmod_coef$t6_shape,
                           scale = transmod_coef$t6_scale), 
              dist = "weibullPH"),
  # 7. R3_P4 -> R4_P5
  params_surv(coefs = list(shape = transmod_coef$t7_shape,
                           scale = transmod_coef$t7_scale), 
              dist = "weibullPH"),
  # 8 R3_P4 -> Death
  params_surv(coefs = list(shape = transmod_coef$t8_shape,
                           scale = transmod_coef$t8_scale),
              dist = "weibullPH"),
  # 9. R4_P5 -> R5
  params_surv(coefs = list(shape = transmod_coef$t9_shape,
                           scale = transmod_coef$t9_scale),
              dist = "weibullPH"),
  # 10. R4_P5 -> Death
  params_surv(coefs = list(shape = transmod_coef$t10_shape,
                           scale = transmod_coef$t10_scale),
              dist = "weibullPH"),
  # 11. R5 -> Death
  params_surv(coefs = list(shape = transmod_coef$t11_shape,
                           scale = transmod_coef$t11_scale),
              dist = "weibullPH")
)

transmod_data <- expand(hesim_dat, by = c("strategies", "patients"))

transmod_data[, cons := 1]  ## constant term created by transmod
transmod_data[, st1:= ifelse(strategy_name == "Sequence 1",1,0) ]
transmod_data[, st2:= ifelse(strategy_name == "Sequence 2",1,0) ]
transmod_data[, st3:= ifelse(strategy_name == "Sequence 3",1,0) ]
transmod_data[, notst3:= ifelse(strategy_name != "Sequence 3",1,0)]
transmod_data[, notst2:= ifelse(strategy_name != "Sequence 2",1,0)]

```

The next lines of code create the individual transition model. It uses the transition parameters (`transmod_paras`), the population data along with the strategies (`transmod_data`) and the matrix of valid transitions within the model (`tmat`)

```{r transition_model, echo=TRUE}
# Transition model ----
transmod <- create_IndivCtstmTrans(transmod_params, 
                                   input_data = transmod_data,
                                   trans_mat = tmat,
                                   clock = "reset")
```

\newpage

## Utility

Utilities per sequence (`strateg_id`) and state (`state_id`) are used by the model to estimate QALYs. For each simulation of the model, utility values are sample from a beta distribution with mean $m$ and standard error $\varepsilon$. Table \@ref(tab:UtilTable) displays the predetermined utility values used in the study. The chunk below indicates how the predetermined utility inputs are loaded into the model to create a object that the `hesim` package used to estimate population QALYs.

```{r utility, echo=TRUE}

# Utility ----
load("../data/utility_data.rda") # predetermined utility inputs
utility_tbl <- stateval_tbl(utility_data,
                            dist = "beta")
```

```{r UtilTable, echo=FALSE}
knitr::kable(utility_tbl,
             longtable = T,
             booktabs = T, linesep = "",
             caption = "Utility parameters",
             align = "lcrrr") %>%
  kableExtra::kable_styling("striped", 
                            full_width =F,
                            latex_options = "hold_position")
#             kable_styling("striped", full_width = F)
             
utilitymod <- create_StateVals(utility_tbl, n = n_samples, hesim_data = hesim_dat)
```

The chunk below created the economic model.

```{r econmod, echo=TRUE}

econmod <- IndivCtstm$new(trans_model = transmod,
                          utility_model = utilitymod
)
```

\newpage

# Simulation

## Disease Progression

The next chunk runs the disease progression model.

```{r disprog, echo=TRUE}

# Simulation ----
ptm <- proc.time()
econmod$sim_disease()
proc.time() - ptm
```

Table \@ref(tab:disprogsnippet) shows a snippet of the output of the disease progression model.

```{r disprogsnippet, echo=FALSE}
snippet <- head(econmod$disprog_,10)  ### results from simulation

knitr::kable(snippet,
             longtable = T,
  booktabs = T, linesep = "",
  caption = "Disease progression output")  %>%
  kableExtra::kable_styling( bootstrap_options = 'striped',
    latex_options = "hold_position")#  kable_styling("striped", full_width = F)
```

# Disease Progression Outputs

The next chunks use the output of the individual disease progression model simulation to create tables that summarize statistics on the time to progression, time to death pre-progression, progression free survival, and OS by line of treatment.

```{r time_spent, echo=TRUE}
econmod$disprog_[, `:=`(transition = paste0(from,'_',to), time_spent= time_stop - time_start), ]
# Some useful summary tables ----
disprog <- copy(econmod$disprog_)

disprog <- disprog[,.( progressed = .N,
  mean_time_spent = mean(time_spent), 
  median_time_spent = median(time_spent)
  ),
  by = .(sample, strategy_id, transition, from, to,final)]

##  Time to progression summary ----
summary_dis <- disprog[,.( mean_progressed = mean(progressed),
                           mean_time_spent = mean(mean_time_spent), 
                           med_time_spent = median(mean_time_spent),
                           time_spent05 = quantile(mean_time_spent,.05), 
                           time_spent95 = quantile(mean_time_spent,.95)), 
                       .(strategy_id, from, to, transition)
                       ][order(strategy_id, transition)]
per_line <- summary_dis[, .(mean_entry = sum(mean_progressed)), by = .(strategy_id,from)]

summary_dis <- left_join(summary_dis,per_line,by = c("strategy_id","from"))

summary_dis <- summary_dis[,.(strategy_id, from, mean_entry, to, mean_progressed,  
                              mean_time_spent, med_time_spent, time_spent05, time_spent95)]
summary_dis[, `:=`(proportion= ifelse(mean_entry==0,"-", round(mean_progressed/mean_entry,2)),
                   init_prop = round(mean_entry/n_patients,2))
            ]
names(summary_dis) <- c("Strategy", "from", "Entered",
                         "to", "Exited",  "Mean", "Median",
                         "Low 5%", "Top 5%", "Proportion", "% of initial pop")
#rm(per_line, disprog)
summary_dis <- summary_dis[, `:=`(`From Line` = ifelse(from == 6, "5+", from),
                                  `To Line` = ifelse(to == 7, "D", ifelse(to == 6, "5+",to)),
                                  `Mean Duration` = round(Mean,2),
                                  `Median Duration` = round(Median,2),
                                  `95% - CI` = paste0("(",round(`Low 5%`,2),", ",
                                  round(`Top 5%`,2), ")")
                                  )]
summary_dis[, Transition := paste(`From Line`,'to', `To Line`)]
summary_dis <- summary_dis[,.(Strategy, `From Line`, `To Line`,
                              Transition, Proportion, `% of initial pop`,
                              `Mean Duration`, `Median Duration`,
                              `95% - CI`)]

rm(disprog) # remove object not needed anymore
```

## Time to Progression (TTP)

The chunk below creates a table (see Table \@ref(tab:summaryProg)) of summary statistics for time to progression (TTP).

```{r summaryProg, echo=TRUE}
## Progression and survival per line of treatment summary ----
tbl_summaryP <- summary_dis[`To Line`!= "D", .(
  Strategy, `% of initial pop`,
  Transition, `Proportion`,
  `Median Duration`, `Mean Duration`, 
  `95% - CI`)]
names(tbl_summaryP)[c(4,5,6)] <- c("% who progressed", "Median TTP", "Mean TTP")
 
knitr::kable(tbl_summaryP,
  longtable = T,
  booktabs = T, 
  caption = "Time to progression (TTP) per line of treatment",
  align = "lcrrrr") %>%
  kableExtra::kable_styling('striped', latex_options = "hold_position")
```

## Time to Death Pre-Progression (TTDP)

The next chunk creates a table (see Table \@ref(tab:summaryDeath)) showing a summary statistics time to death pre-progression.

```{r summaryDeath, echo=TRUE, message=FALSE}
# progression to death summary
tbl_summaryD <- summary_dis[`To Line`== "D", .(
  Strategy, `% of initial pop`,
  Transition, `Proportion`,
  `Median Duration`, `Mean Duration`, 
  `95% - CI`)]
names(tbl_summaryD)[c(4,5,6)] <- c("% who died", "Median TTDP", "Mean TTDP")

knitr::kable(tbl_summaryD,
  longtable = T,
  booktabs = T,
  linesep = linesep(c(6,6,6)),
  caption = "Time to death pre-pregression (TTDP) per line of treatment",
  align = "lcrrrr") %>%
  kableExtra::kable_styling('striped', latex_options = "hold_position")

rm(summary_dis) # remove objects that are no longer needed
```

## Progression Free Survival (PFS)

The next chunk creates a table (see Table \@ref(tab:summaryPFS)) showing a summary statistics on progression free survival (PFS), that is time to progression or death pre-progression.

```{r summaryPFS, echo=TRUE, message=FALSE}
summary_dis <- econmod$disprog_[,.( mean_time_spent = mean(time_spent), 
                                median_time_spent = median(time_spent)
                                ),
                            by = .(sample, strategy_id, from)]

##  Time to progression summary ----
summary_dis <- summary_dis[,.(med_time_spent = mean(median_time_spent),
                          mean_time_spent = mean(mean_time_spent), 
                          time_spent05 = quantile(mean_time_spent,.05), 
                          time_spent95 = quantile(mean_time_spent,.95)), 
                       .(strategy_id, from)
                       ][order(strategy_id)]
per_line[,prop_init := mean_entry/n_patients]
summary_dis <- left_join(summary_dis, per_line[,.(strategy_id, from, prop_init)],
                         by = c('strategy_id', 'from'))
names(summary_dis) <- c("Strategy", "LOT",
                          "Median", "Mean",
                         "Low 5%", "Top 5%", "% of initial pop")
summary_dis <- summary_dis[, `:=`(`LOT` = ifelse(LOT == 6, "5+", LOT),
                                  `Median PFS` = round(Median,2),
                                  `Mean PFS` = round(Mean,2),
                                  `95% - CI` = paste0("(",round(`Low 5%`,2),", ",
                                  round(`Top 5%`,2), ")")
                                  )]

# PFS tbl
tbl_summaryPFS <- summary_dis[, .(Strategy, `% of initial pop`, LOT,
            `Median PFS`, `Mean PFS`, 
            `95% - CI`)]
tbl_summaryPFS$`% of initial pop` <- round(tbl_summaryPFS$`% of initial pop`,2)

knitr::kable(tbl_summaryPFS,
  longtable = T,
  booktabs = T,
  linesep = linesep(c(6,6,6)),
  caption = "Progression free survival (PFS) per line of treatment",
  align = "rrrrr") %>%
  kableExtra::kable_styling('striped', latex_options = "hold_position")

 rm(summary_dis)
```

## Overal Survival (OS)

The next chunk creates a table (see Table \@ref(tab:summaryOS)) showing a summary statistics on OS per line of treatment.

```{r summaryOS, echo=FALSE}
summary_dis <- lapply(1:6, function(k){econmod$disprog_[from >= k, .(TTD = sum(time_spent)),
                                               by = .(sample, strategy_id, patient_id)]})
summary_dis <- lapply(1:6, function(k){ summary_dis[[k]][, from := k]})
summary_dis <- do.call(rbind, summary_dis)

summary_dis <- summary_dis[, .(OSmean = mean(TTD), OSmedian = median(TTD) ),
         by = .(sample, strategy_id, from)]
summary_dis <- summary_dis[,.(medianOS = mean(OSmedian),
                              meanOS = mean(OSmean),
                              low = quantile(OSmean, .025),
                              up = quantile(OSmean, .975)),
                           by = .(strategy_id, from)]
summary_dis <- summary_dis[order(strategy_id, from)]
summary_dis <- left_join(summary_dis, per_line[,.(strategy_id, from, prop_init)],
                         by = c('strategy_id', 'from'))
names(summary_dis) <- c("Strategy", "LOT",
                          "Median", "Mean",
                         "Low 5%", "Top 5%", "% of initial pop")
summary_dis <- summary_dis[, `:=`(`LOT` = ifelse(LOT == 6, "5+", LOT),
                                  `Median OS` = round(Median,2),
                                  `Mean OS` = round(Mean,2),
                                  `95% - CI` = paste0("(",round(`Low 5%`,2),", ",
                                  round(`Top 5%`,2), ")")
                                  )]

# OS tbl
tbl_summaryOS <- summary_dis[, .(Strategy, `% of initial pop`, LOT,
            `Median OS`, `Mean OS`, 
            `95% - CI`)]
tbl_summaryOS$`% of initial pop` <- round(tbl_summaryOS$`% of initial pop`,2)

knitr::kable(tbl_summaryOS,
  longtable = T,
  booktabs = T,
  linesep = linesep(c(6,6,6)),
  caption = "Overall survival (OS) from line of treatment",
  align = "rrrrr") %>%
  kableExtra::kable_styling('striped', latex_options = "hold_position")

 rm(summary_dis, per_line)
```

\newpage

## Time to Progression (TTP) at Second Line

A comparison of time to progression (TTP) at second line of treatment is done to evaluate the performance of the different sequence strategies. The chunk below creates a graph (see Figure \@ref(fig:figTTP2l)) displaying TTP for individuals who progressed to second line.

```{r figTTP2l,  fig.align='center', fig.cap="\\label{fig:fig2}TTP at 2nd line", fig.pos='H', echo=TRUE, warning=FALSE}
### Time to progression at second line ----
pfsl2.data <- econmod$disprog_[from ==2,] 
pfs_data <- lapply(seq(0,30, by =.5), 
                    function(x){data.table(t=x,pfsl2.data[,.(prob = mean(time_spent>x)),
                                                          by =.(sample,strategy_id)])})
pfs_data <- do.call(rbind, pfs_data)
pfs_data <- pfs_data[, .(prob_mean = mean(prob),
                         ci_l = quantile(prob, .025),
                         ci_u = quantile(prob, .975)),
                     by = .(t,strategy_id)]
setorder(pfs_data, strategy_id, t)
set_labels(pfs_data, labels = labs, new_names = c("strategy_name"))
ggplot(pfs_data, aes(x = t, y = prob_mean, col = strategy_name)) +
  geom_line() +  ylim(0,1) +
  geom_ribbon(aes(ymin = ci_l, ymax = ci_u, fill = strategy_name), alpha = .2, linetype=0) +
  xlab("Years") + ylab("Probability") +
  ggtitle("Time to Progression at 2nd Line") +
  theme(legend.position = "bottom",
        legend.title = element_blank(),
        plot.title = element_text(hjust = 0.5))

```

## Progression Free Survival (PFS) at Second Line

A comparison of progression free survival (PFS) at second line of treatment is done to evaluate the performance of the different sequence strategies. The chunk below creates a graph (see Figure \@ref(fig:figPFS2l)) displaying the PFS for individuals who progressed to second line.

```{r figPFS2l,  fig.align='center', fig.cap="\\label{fig:fig2}PFS at 2nd line", fig.pos='H', echo=TRUE, warning=FALSE}
### Progression free survival at second line ----
pfsl2.data <- econmod$disprog_[from ==2,] 
pfs_data <- lapply(seq(0,30, by =.5), 
                    function(x){data.table(t=x,pfsl2.data[,.(prob = mean(time_spent>x)),
                                                          by =.(sample,strategy_id)])})
pfs_data <- do.call(rbind, pfs_data)
pfs_data <- pfs_data[, .(prob_mean = mean(prob),
                         ci_l = quantile(prob, .025),
                         ci_u = quantile(prob, .975)),
                     by = .(t,strategy_id)]
setorder(pfs_data, strategy_id, t)
set_labels(pfs_data, labels = labs, new_names = c("strategy_name"))
ggplot(pfs_data, aes(x = t, y = prob_mean, col = strategy_name)) +
  geom_line() +  ylim(0,1) +
  geom_ribbon(aes(ymin = ci_l, ymax = ci_u, fill = strategy_name), alpha = .2, linetype=0) +
  xlab("Years") + ylab("Probability") +
  ggtitle("Progression Free Survival at 2nd Line") +
  theme(legend.position = "bottom",
        legend.title = element_blank(),
        plot.title = element_text(hjust = 0.5))

rm(pfsl2.data, pfs_data) # remove objects no longer in use
```

\newpage

## Overall Survival from Second Line

To further evaluate the performance of the second line treatments of each strategy sequence, a comparison of OS starting from second line is useful. The chunk below creates a graph (see Figure \@ref(fig:fig2)) displaying the OS of individuals who progressed to second line for each sequence strategy in the model.

```{r fig2,  fig.align='center', fig.cap="\\label{fig:fig2}Overall survival from 2nd line", fig.pos='H', echo=TRUE, warning=FALSE}
rm(tbl_summaryD, tbl_summaryP, tbl_summaryPFS) # remove objects no longer in use 

### Overall Survival for those who achieve second line ----

osl2.data <- econmod$disprog_[from!=1, .(OS = sum(time_spent)), 
                              by = .(sample, strategy_id, patient_id)]
prob_data <- lapply(seq(0,30, by =.5), 
                    function(x){data.table(t=x,osl2.data[,.(prob = mean(OS>x)),
                                                         by =.(sample,strategy_id)])})
prob_data <- do.call(rbind, prob_data)
prob_data <- prob_data[, .(prob_mean = mean(prob),
                           ci_l = quantile(prob, .025),
                           ci_u = quantile(prob, .975)),
                       by = .(t,strategy_id)]
setorder(prob_data, strategy_id, t)
set_labels(prob_data, labels = labs, new_names = c("strategy_name"))
ggplot(prob_data, aes(x = t, y = prob_mean, col = strategy_name)) +
  geom_line() +  ylim(0,1) +
  geom_ribbon(aes(ymin = ci_l, ymax = ci_u, fill = strategy_name), alpha = .2, linetype=0) +
  xlab("Years") + ylab("Survival probability") +
  ggtitle("Overall Survival from 2nd Line") +
  theme(legend.position = "bottom",
        legend.title = element_blank(),
        plot.title = element_text(hjust = 0.5))
rm(osl2.data, prob_data, summary_dis) # remove objects that are no longer used
```

\newpage

## State Probabilities

The time evolution of state probabilities (probability that on individual is in any given state at any point in time) are also useful to evaluate the performance of the different sequence strategies. The chunk below creates a group of graphs showing the state probabilities (see Figure \@ref(fig:fig3)).

```{r fig3, fig.align='center', fig.cap="\\label{fig:fig3}State probabilities for each line of treatment per sequence", fig.pos='H', echo=TRUE, warning=FALSE, fig.dim = c(6, 8) }

 ## Plot of state probabilities ----
econmod$sim_stateprobs(t = seq(0, 30, .5)) 
summarize_stprobs <- function(stateprobs){
  x <- stateprobs[, .(prob_mean = mean(prob), 
                      low_prob_2.5 = quantile(prob, .025),
                      up_prob_2.5 = quantile(prob, .975)),
                  by = c("strategy_id", "state_id", "t")]
  set_labels(x, labels = labs, new_names = c("strategy_name", "state_name"))
}

stprobs <- summarize_stprobs(econmod$stateprobs_)
ggplot(stprobs, aes(x = t, y = prob_mean, col = strategy_name)) +
  geom_line() +  
  geom_ribbon(aes(ymin = low_prob_2.5, ymax = up_prob_2.5, fill = strategy_name), alpha = 0.2, linetype=0) +
  facet_wrap(~state_name,ncol = 2) + 
  xlab("Years") + ylab("Probability in health state") +
  # scale_color_discrete(name = "Strategy") +
  theme(legend.position = "bottom", 
        legend.title = element_blank())
```

\newpage

## QALYs

A discount factor $v=(1+r)^{-1}$, $0\leq r<1$, is used in the model to estimate total discounted QALYs. The following chunk defines the discount rate and factors.

```{r ecoanalysis, echo=TRUE}
disc <- 0.03 # Annual discount rate
v <- 1/(1+disc) # discount factor
```

The next chunk performs the estimation of total QALYs

```{r qalysim, echo=TRUE}
# QALYs model ----
econmod$sim_qalys(dr = disc)
```

A snippet of the output from the QALY model is in Table \@ref(tab:qalySimOut).

```{r qalySimOut, echo=FALSE}
snippet <- head(econmod$qalys_,10)
knitr::kable(snippet,
             digits = 2,
             longtable = T,
             booktabs = T, linesep = "",
             caption = "Snippet of QALY outcomes",
             align = "lcrrr") %>%
  kableExtra::kable_styling('striped', latex_options = "hold_position")
#             kable_styling("striped", full_width = F)

rm(snippet) # remove objects no longer used
```

Chart \@ref(fig:fig4)) shows the average QALYs for each strategy sequence broken down by line of treatments.

```{r fig4, fig.align='center', fig.cap="\\label{fig:fig4}Average QALYs", fig.ps='H', echo=TRUE}
## Summary of average QALYs per line of treatment ----
qaly_chart <- chart.LOT(econmod$qalys_,'QALYs')
qaly_chart$plot + ggtitle("Average QALYs") +
  theme(plot.title = element_text(hjust = 0.5) ) 
```

Table \@ref(tab:summaryqalys) shows a summary of QALYs statistics.

```{r summaryqalys, echo=TRUE}
qs <- econmod$qalys_[,.(qalys = sum(qalys)), by =.(strategy_id, sample,dr)]
qs <- qs[, .(mean = mean(qalys), 
            low2.5 = quantile(qalys, .025),
            up2.5 =quantile(qalys, .975)
            ),
         by = .(strategy_id, dr)]
qs <- qs[, `:=`(CI=paste0(round(mean,2),' (',round(low2.5,2), ', ',round(up2.5,2),')'))]
qalySum_tbl <- data.table(Outcome = 'QALYs', t(qs[,.(CI)]))
names(qalySum_tbl)[-1] <- paste0('Sequence',1:3)

rm(qs) # remove objects that are no longer needed

knitr::kable(qalySum_tbl,
             longtable = T,
             booktabs = T, 
             caption = "QALYs summary") %>%
  kableExtra::kable_styling('striped', latex_options = "hold_position")

```

------------------------------------------------------------------------

# References
